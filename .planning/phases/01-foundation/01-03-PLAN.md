---
phase: 01-foundation
plan: 03
type: execute
wave: 3
depends_on: ["01-01", "01-02"]
files_modified:
  - src/validator/index.ts
  - src/validator/structural.ts
  - src/validator/references.ts
  - src/validator/cycles.ts
  - src/cli/index.ts
  - src/cli/validate.ts
  - src/cli/format.ts
autonomous: true

must_haves:
  truths:
    - "User can run `flowscript validate example.flow.md` and get pass/fail result"
    - "Validator catches missing required fields and reports with line numbers"
    - "Validator catches undefined node references (input attribute) and suggests fixes"
    - "Validator catches undeclared secrets and reports which are missing"
    - "Validator catches duplicate node IDs within the workflow"
    - "Validator detects circular dependencies and shows the cycle path"
    - "CLI displays errors with source code context (like TypeScript/ESLint)"
    - "CLI exits with code 0 on valid, code 1 on invalid"
  artifacts:
    - src/validator/index.ts
    - src/validator/structural.ts
    - src/validator/references.ts
    - src/validator/cycles.ts
    - src/cli/index.ts
    - src/cli/validate.ts
    - src/cli/format.ts
  key_links:
    - "validate() takes WorkflowAST and returns ValidationResult"
    - "CLI validate command calls parse() then validate()"
    - "Error formatter uses @babel/code-frame for source context"
---

<objective>
Implement the FlowScript validator and CLI validate command that lets users validate .flow.md files and receive clear error messages with source locations.

Purpose: Complete the validation loop - users can check workflows before execution
Output: Working `flowscript validate <file>` command with compiler-quality error messages
</objective>

<execution_context>
@/Users/narcisbrindusescu/.claude/looppool/workflows/execute-plan.md
@/Users/narcisbrindusescu/.claude/looppool/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/01-foundation/01-RESEARCH.md
@.planning/phases/01-foundation/01-01-SUMMARY.md
@.planning/phases/01-foundation/01-02-SUMMARY.md

Research patterns to implement:
- Multi-pass validation (structural, references, cycles, semantics)
- Kahn's algorithm for cycle detection (O(V+E))
- @babel/code-frame for compiler-style error messages
- commander for CLI framework

Requirements covered:
- VALID-01: Check all required fields present on nodes
- VALID-02: Verify all node references resolve to defined nodes
- VALID-04: Detect circular dependencies and report clear error
- VALID-05: Check all referenced secrets are declared in frontmatter
- VALID-06: Ensure node IDs are unique within scope
- CLI-01: `flowscript validate <file>` validates without executing
- CLI-04: CLI displays clear error messages with source locations
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement validator passes (structural, references, cycles)</name>
  <files>src/validator/structural.ts, src/validator/references.ts, src/validator/cycles.ts, src/validator/index.ts</files>
  <action>
    1. Create src/validator/structural.ts for structural validation:
       ```typescript
       import type { WorkflowAST, NodeAST, ValidationError } from '../types';
       import { createError, createWarning } from '../types';

       /**
        * Validate structural integrity: required fields, valid attributes.
        * This is Pass 1 - runs before reference validation.
        */
       export function validateStructure(ast: WorkflowAST): ValidationError[] {
         const errors: ValidationError[] = [];

         // Check metadata required fields (already validated by parser, but double-check)
         if (!ast.metadata.name) {
           errors.push(createError(
             'VALID_MISSING_REQUIRED_FIELD',
             'Workflow metadata missing required field: name',
             undefined,
             ['Add name: your-workflow-name to the frontmatter']
           ));
         }

         if (!ast.metadata.version) {
           errors.push(createError(
             'VALID_MISSING_REQUIRED_FIELD',
             'Workflow metadata missing required field: version',
             undefined,
             ['Add version: 1.0.0 to the frontmatter']
           ));
         }

         // Validate each node
         for (const node of ast.nodes) {
           errors.push(...validateNode(node));
         }

         return errors;
       }

       function validateNode(node: NodeAST): ValidationError[] {
         const errors: ValidationError[] = [];

         // All nodes must have an id
         if (!node.id) {
           errors.push(createError(
             'VALID_MISSING_REQUIRED_FIELD',
             `<${node.type}> element missing required 'id' attribute`,
             node.loc,
             [`Add id="unique-name" to the <${node.type}> element`]
           ));
         }

         // Type-specific validation
         switch (node.type) {
           case 'source':
             if (!node.sourceType) {
               errors.push(createError(
                 'VALID_MISSING_REQUIRED_FIELD',
                 `<source id="${node.id}"> missing required 'type' attribute`,
                 node.loc,
                 ['Add type="http" or type="file" to specify the source type']
               ));
             }
             break;

           case 'transform':
             if (!node.transformType) {
               errors.push(createError(
                 'VALID_MISSING_REQUIRED_FIELD',
                 `<transform id="${node.id}"> missing required 'type' attribute`,
                 node.loc,
                 ['Add type="ai", type="template", type="map", or type="filter"']
               ));
             }
             break;

           case 'sink':
             if (!node.sinkType) {
               errors.push(createError(
                 'VALID_MISSING_REQUIRED_FIELD',
                 `<sink id="${node.id}"> missing required 'type' attribute`,
                 node.loc,
                 ['Add type="http" or type="file" to specify the sink type']
               ));
             }
             break;

           case 'if':
             if (!node.condition) {
               errors.push(createError(
                 'VALID_MISSING_REQUIRED_FIELD',
                 `<if id="${node.id}"> missing required 'condition' attribute`,
                 node.loc,
                 ['Add condition="{{expression}}" to specify when to branch']
               ));
             }
             break;

           case 'while':
             if (!node.condition) {
               errors.push(createError(
                 'VALID_MISSING_REQUIRED_FIELD',
                 `<while id="${node.id}"> missing required 'condition' attribute`,
                 node.loc,
                 ['Add condition="{{expression}}" to specify loop condition']
               ));
             }
             break;

           case 'foreach':
             if (!node.collection) {
               errors.push(createError(
                 'VALID_MISSING_REQUIRED_FIELD',
                 `<foreach id="${node.id}"> missing required 'collection' attribute`,
                 node.loc,
                 ['Add collection="{{node.output.items}}" to specify what to iterate']
               ));
             }
             break;

           case 'checkpoint':
             if (!node.prompt) {
               errors.push(createError(
                 'VALID_MISSING_REQUIRED_FIELD',
                 `<checkpoint id="${node.id}"> missing required <prompt> element`,
                 node.loc,
                 ['Add <prompt>Your message here</prompt> inside the checkpoint']
               ));
             }
             break;
         }

         return errors;
       }
       ```

    2. Create src/validator/references.ts for reference validation:
       ```typescript
       import type { WorkflowAST, NodeAST, ValidationError } from '../types';
       import { createError } from '../types';

       export interface SymbolTable {
         nodes: Map<string, NodeAST>;      // id -> node
         secrets: Set<string>;              // Declared secrets
         nodeReferences: Map<string, string[]>;  // id -> referenced node ids
       }

       /**
        * Build a symbol table from the AST for reference resolution.
        */
       export function buildSymbolTable(ast: WorkflowAST): SymbolTable {
         const nodes = new Map<string, NodeAST>();
         const secrets = new Set<string>(ast.metadata.secrets || []);
         const nodeReferences = new Map<string, string[]>();

         // Collect all node IDs
         for (const node of ast.nodes) {
           collectNodes(node, nodes);
         }

         // Collect references (input attributes)
         for (const node of ast.nodes) {
           collectReferences(node, nodeReferences);
         }

         return { nodes, secrets, nodeReferences };
       }

       function collectNodes(node: NodeAST, nodes: Map<string, NodeAST>): void {
         if (node.id) {
           nodes.set(node.id, node);
         }

         // Recurse into nested nodes
         if ('body' in node && Array.isArray(node.body)) {
           for (const child of node.body) {
             collectNodes(child, nodes);
           }
         }
         if ('then' in node && Array.isArray(node.then)) {
           for (const child of node.then) {
             collectNodes(child, nodes);
           }
         }
         if ('else' in node && Array.isArray(node.else)) {
           for (const child of node.else) {
             collectNodes(child, nodes);
           }
         }
         if ('cases' in node && Array.isArray(node.cases)) {
           for (const c of node.cases) {
             for (const child of c.nodes) {
               collectNodes(child, nodes);
             }
           }
         }
         if ('branches' in node && Array.isArray(node.branches)) {
           for (const branch of node.branches) {
             for (const child of branch) {
               collectNodes(child, nodes);
             }
           }
         }
       }

       function collectReferences(node: NodeAST, refs: Map<string, string[]>): void {
         const nodeRefs: string[] = [];

         // Input attribute references another node
         if (node.input) {
           nodeRefs.push(node.input);
         }

         refs.set(node.id, nodeRefs);

         // Recurse into nested nodes
         if ('body' in node && Array.isArray(node.body)) {
           for (const child of node.body) {
             collectReferences(child, refs);
           }
         }
         // ... similar for then, else, cases, branches
       }

       /**
        * Validate all references resolve to defined symbols.
        * This is Pass 2.
        */
       export function validateReferences(
         ast: WorkflowAST,
         symbols: SymbolTable
       ): ValidationError[] {
         const errors: ValidationError[] = [];

         // Check for duplicate node IDs
         const seenIds = new Map<string, NodeAST>();
         for (const node of ast.nodes) {
           checkDuplicateIds(node, seenIds, errors);
         }

         // Check all input references resolve
         for (const node of ast.nodes) {
           checkNodeReferences(node, symbols, errors);
         }

         // Check all secret references resolve
         checkSecretReferences(ast, symbols, errors);

         return errors;
       }

       function checkDuplicateIds(
         node: NodeAST,
         seen: Map<string, NodeAST>,
         errors: ValidationError[]
       ): void {
         if (node.id) {
           const existing = seen.get(node.id);
           if (existing) {
             errors.push(createError(
               'VALID_DUPLICATE_NODE_ID',
               `Duplicate node ID: '${node.id}' is already defined`,
               node.loc,
               [
                 `First defined at line ${existing.loc.start.line}`,
                 'Use a unique ID for each node'
               ]
             ));
           } else {
             seen.set(node.id, node);
           }
         }

         // Recurse into nested nodes
         if ('body' in node && Array.isArray(node.body)) {
           for (const child of node.body) {
             checkDuplicateIds(child, seen, errors);
           }
         }
         if ('then' in node && Array.isArray(node.then)) {
           for (const child of node.then) {
             checkDuplicateIds(child, seen, errors);
           }
         }
         if ('else' in node && Array.isArray(node.else)) {
           for (const child of node.else) {
             checkDuplicateIds(child, seen, errors);
           }
         }
       }

       function checkNodeReferences(
         node: NodeAST,
         symbols: SymbolTable,
         errors: ValidationError[]
       ): void {
         // Check input reference
         if (node.input && !symbols.nodes.has(node.input)) {
           const suggestions = suggestSimilar(node.input, [...symbols.nodes.keys()]);
           errors.push(createError(
             'VALID_UNDEFINED_NODE_REF',
             `Node '${node.id}' references undefined node '${node.input}'`,
             node.loc,
             suggestions.length > 0
               ? [`Did you mean: ${suggestions.join(', ')}?`]
               : [`Define a node with id="${node.input}" before referencing it`]
           ));
         }

         // Recurse
         if ('body' in node && Array.isArray(node.body)) {
           for (const child of node.body) {
             checkNodeReferences(child, symbols, errors);
           }
         }
         if ('then' in node && Array.isArray(node.then)) {
           for (const child of node.then) {
             checkNodeReferences(child, symbols, errors);
           }
         }
         if ('else' in node && Array.isArray(node.else)) {
           for (const child of node.else) {
             checkNodeReferences(child, symbols, errors);
           }
         }
       }

       function checkSecretReferences(
         ast: WorkflowAST,
         symbols: SymbolTable,
         errors: ValidationError[]
       ): void {
         // Find all {{$secrets.NAME}} references in node configs
         const secretPattern = /\{\{\s*\$secrets\.(\w+)\s*\}\}/g;

         for (const node of ast.nodes) {
           const configStr = JSON.stringify(node.config || {});
           let match: RegExpExecArray | null;

           while ((match = secretPattern.exec(configStr)) !== null) {
             const secretName = match[1];
             if (!symbols.secrets.has(secretName)) {
               errors.push(createError(
                 'VALID_UNDEFINED_SECRET_REF',
                 `Node '${node.id}' references undeclared secret '${secretName}'`,
                 node.loc,
                 [`Add '${secretName}' to the secrets array in frontmatter`]
               ));
             }
           }
         }
       }

       /**
        * Suggest similar node IDs for typo correction.
        */
       function suggestSimilar(target: string, candidates: string[]): string[] {
         return candidates
           .filter(c => {
             // Simple Levenshtein-ish heuristic
             const common = [...target].filter(char => c.includes(char)).length;
             return common >= target.length * 0.5;
           })
           .slice(0, 3);
       }
       ```

    3. Create src/validator/cycles.ts for cycle detection:
       ```typescript
       import type { WorkflowAST, ValidationError } from '../types';
       import { createError } from '../types';
       import type { SymbolTable } from './references';

       /**
        * Detect circular dependencies using Kahn's algorithm (topological sort).
        * This is Pass 3.
        */
       export function detectCycles(
         ast: WorkflowAST,
         symbols: SymbolTable
       ): ValidationError[] {
         const errors: ValidationError[] = [];

         // Build dependency graph
         const inDegree = new Map<string, number>();
         const dependents = new Map<string, string[]>();  // node -> nodes that depend on it

         // Initialize
         for (const [id] of symbols.nodes) {
           inDegree.set(id, 0);
           dependents.set(id, []);
         }

         // Count incoming edges (dependencies)
         for (const [nodeId, refs] of symbols.nodeReferences) {
           if (!symbols.nodes.has(nodeId)) continue;

           for (const refId of refs) {
             if (symbols.nodes.has(refId)) {
               // nodeId depends on refId
               inDegree.set(nodeId, (inDegree.get(nodeId) || 0) + 1);
               dependents.get(refId)?.push(nodeId);
             }
           }
         }

         // Kahn's algorithm - start with nodes that have no dependencies
         const queue: string[] = [];
         for (const [id, degree] of inDegree) {
           if (degree === 0) {
             queue.push(id);
           }
         }

         const sorted: string[] = [];
         while (queue.length > 0) {
           const node = queue.shift()!;
           sorted.push(node);

           // Reduce in-degree for all dependents
           for (const dependent of dependents.get(node) || []) {
             const newDegree = (inDegree.get(dependent) || 1) - 1;
             inDegree.set(dependent, newDegree);
             if (newDegree === 0) {
               queue.push(dependent);
             }
           }
         }

         // If not all nodes were sorted, there's a cycle
         if (sorted.length < symbols.nodes.size) {
           const cycleNodes = [...symbols.nodes.keys()].filter(id => !sorted.includes(id));

           // Find and report the cycle path
           const cyclePath = traceCyclePath(cycleNodes, symbols);
           const firstNode = symbols.nodes.get(cycleNodes[0]);

           errors.push(createError(
             'VALID_CIRCULAR_DEPENDENCY',
             `Circular dependency detected: ${cyclePath.join(' -> ')} -> ${cyclePath[0]}`,
             firstNode?.loc,
             [
               'Remove one of the input references to break the cycle',
               'Consider restructuring to use a sequential flow'
             ]
           ));
         }

         return errors;
       }

       /**
        * Trace a path through the cycle for clear error reporting.
        */
       function traceCyclePath(cycleNodes: string[], symbols: SymbolTable): string[] {
         if (cycleNodes.length === 0) return [];

         const path: string[] = [cycleNodes[0]];
         const visited = new Set<string>([cycleNodes[0]]);

         let current = cycleNodes[0];
         while (path.length < cycleNodes.length) {
           const refs = symbols.nodeReferences.get(current) || [];
           const nextInCycle = refs.find(r => cycleNodes.includes(r) && !visited.has(r));

           if (nextInCycle) {
             path.push(nextInCycle);
             visited.add(nextInCycle);
             current = nextInCycle;
           } else {
             // Can't continue, just add remaining cycle nodes
             for (const node of cycleNodes) {
               if (!visited.has(node)) {
                 path.push(node);
                 visited.add(node);
               }
             }
             break;
           }
         }

         return path;
       }
       ```

    4. Create src/validator/index.ts as the main entry point:
       ```typescript
       import type { WorkflowAST, ValidationResult, ValidationError } from '../types';
       import { validateStructure } from './structural';
       import { buildSymbolTable, validateReferences } from './references';
       import { detectCycles } from './cycles';

       /**
        * Validate a parsed WorkflowAST.
        *
        * Validation runs in multiple passes:
        * 1. Structural validation (required fields, valid attributes)
        * 2. Reference validation (node refs, secret refs, duplicate IDs)
        * 3. Cycle detection (circular dependencies)
        *
        * @param ast - The parsed workflow AST
        * @returns ValidationResult with errors and warnings
        */
       export function validate(ast: WorkflowAST): ValidationResult {
         const errors: ValidationError[] = [];
         const warnings: ValidationError[] = [];

         // Pass 1: Structural validation
         const structuralErrors = validateStructure(ast);
         if (structuralErrors.length > 0) {
           // Stop early on structural errors - other passes would fail
           return {
             valid: false,
             errors: structuralErrors,
             warnings: []
           };
         }

         // Pass 2: Build symbol table and validate references
         const symbols = buildSymbolTable(ast);
         const referenceErrors = validateReferences(ast, symbols);
         errors.push(...referenceErrors);

         // Pass 3: Detect cycles (only if references are valid)
         if (referenceErrors.filter(e => e.code === 'VALID_UNDEFINED_NODE_REF').length === 0) {
           const cycleErrors = detectCycles(ast, symbols);
           errors.push(...cycleErrors);
         }

         // Separate errors and warnings
         const finalErrors = errors.filter(e => e.severity === 'error');
         const finalWarnings = errors.filter(e => e.severity === 'warning');

         return {
           valid: finalErrors.length === 0,
           errors: finalErrors,
           warnings: [...warnings, ...finalWarnings]
         };
       }

       // Re-export for consumers who need symbol table access
       export { buildSymbolTable } from './references';
       export type { SymbolTable } from './references';
       ```
  </action>
  <verify>
    Run `bun run typecheck` to ensure no type errors
  </verify>
  <done>
    - src/validator/structural.ts validates required fields
    - src/validator/references.ts validates node refs, secret refs, duplicate IDs
    - src/validator/cycles.ts detects circular dependencies using Kahn's algorithm
    - src/validator/index.ts orchestrates multi-pass validation
    - TypeScript compiles without errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement CLI error formatting with code-frame</name>
  <files>src/cli/format.ts</files>
  <action>
    Create src/cli/format.ts for compiler-style error formatting:

    ```typescript
    import { codeFrameColumns } from '@babel/code-frame';
    import chalk from 'chalk';
    import type { ValidationError, ValidationResult, SourceMap } from '../types';

    export interface FormatOptions {
      color?: boolean;
      verbose?: boolean;
    }

    /**
     * Format a single validation error with source context.
     */
    export function formatError(
      error: ValidationError,
      sourceMap: SourceMap,
      options: FormatOptions = {}
    ): string {
      const { color = true } = options;
      const lines: string[] = [];

      // Error header: file:line:column: error[CODE]: message
      const locString = error.loc
        ? `${sourceMap.filePath}:${error.loc.start.line}:${error.loc.start.column + 1}`
        : sourceMap.filePath;

      const severityLabel = error.severity === 'error'
        ? (color ? chalk.red('error') : 'error')
        : (color ? chalk.yellow('warning') : 'warning');

      const codeLabel = color ? chalk.gray(`[${error.code}]`) : `[${error.code}]`;

      lines.push(`${locString}: ${severityLabel}${codeLabel}: ${error.message}`);

      // Source code frame
      if (error.loc) {
        const frame = codeFrameColumns(
          sourceMap.source,
          {
            start: {
              line: error.loc.start.line,
              column: error.loc.start.column + 1  // code-frame uses 1-indexed columns
            },
            end: error.loc.end ? {
              line: error.loc.end.line,
              column: error.loc.end.column + 1
            } : undefined
          },
          {
            highlightCode: color,
            linesAbove: 2,
            linesBelow: 2
          }
        );
        lines.push('');
        lines.push(frame);
      }

      // Hints
      if (error.hints && error.hints.length > 0) {
        lines.push('');
        for (const hint of error.hints) {
          const prefix = color ? chalk.cyan('hint:') : 'hint:';
          lines.push(`  ${prefix} ${hint}`);
        }
      }

      return lines.join('\n');
    }

    /**
     * Format the complete validation result.
     */
    export function formatValidationResult(
      result: ValidationResult,
      sourceMap: SourceMap,
      options: FormatOptions = {}
    ): string {
      const { color = true } = options;
      const lines: string[] = [];

      // Format all errors
      for (const error of result.errors) {
        lines.push(formatError(error, sourceMap, options));
        lines.push('');
      }

      // Format all warnings
      for (const warning of result.warnings) {
        lines.push(formatError(warning, sourceMap, options));
        lines.push('');
      }

      // Summary
      const errorCount = result.errors.length;
      const warningCount = result.warnings.length;

      if (errorCount > 0 || warningCount > 0) {
        const parts: string[] = [];
        if (errorCount > 0) {
          parts.push(color
            ? chalk.red(`${errorCount} error${errorCount === 1 ? '' : 's'}`)
            : `${errorCount} error${errorCount === 1 ? '' : 's'}`
          );
        }
        if (warningCount > 0) {
          parts.push(color
            ? chalk.yellow(`${warningCount} warning${warningCount === 1 ? '' : 's'}`)
            : `${warningCount} warning${warningCount === 1 ? '' : 's'}`
          );
        }
        lines.push(parts.join(', '));
      }

      return lines.join('\n');
    }

    /**
     * Format parse errors (before AST is available).
     */
    export function formatParseErrors(
      errors: ValidationError[],
      source: string,
      filePath: string,
      options: FormatOptions = {}
    ): string {
      const sourceMap: SourceMap = {
        source,
        filePath,
        lineOffsets: buildLineOffsets(source)
      };

      const lines: string[] = [];
      for (const error of errors) {
        lines.push(formatError(error, sourceMap, options));
        lines.push('');
      }

      return lines.join('\n');
    }

    // Inline helper to avoid circular import
    function buildLineOffsets(source: string): number[] {
      const offsets = [0];
      for (let i = 0; i < source.length; i++) {
        if (source[i] === '\n') {
          offsets.push(i + 1);
        }
      }
      return offsets;
    }
    ```
  </action>
  <verify>
    Run `bun run typecheck`
  </verify>
  <done>
    - src/cli/format.ts formats errors with source code context
    - Uses @babel/code-frame for compiler-style output
    - Supports color/no-color mode
    - Shows hints for fixing errors
  </done>
</task>

<task type="auto">
  <name>Task 3: Implement CLI validate command</name>
  <files>src/cli/validate.ts, src/cli/index.ts</files>
  <action>
    1. Create src/cli/validate.ts for the validate command:
       ```typescript
       import { existsSync } from 'fs';
       import { parse } from '../parser';
       import { validate } from '../validator';
       import { formatValidationResult, formatParseErrors } from './format';
       import chalk from 'chalk';

       export interface ValidateOptions {
         format?: 'text' | 'json';
         color?: boolean;
       }

       export interface ValidateResult {
         valid: boolean;
         errorCount: number;
         warningCount: number;
       }

       /**
        * Validate a workflow file and print results.
        */
       export async function validateFile(
         filePath: string,
         options: ValidateOptions = {}
       ): Promise<ValidateResult> {
         const { format = 'text', color = true } = options;

         // Check file exists
         if (!existsSync(filePath)) {
           if (format === 'json') {
             console.log(JSON.stringify({
               valid: false,
               errors: [{
                 code: 'FILE_NOT_FOUND',
                 message: `File not found: ${filePath}`
               }]
             }, null, 2));
           } else {
             console.error(color
               ? chalk.red(`error: File not found: ${filePath}`)
               : `error: File not found: ${filePath}`
             );
           }
           return { valid: false, errorCount: 1, warningCount: 0 };
         }

         // Read file
         const source = await Bun.file(filePath).text();

         // Parse
         const parseResult = parse(source, filePath);

         if (!parseResult.success) {
           if (format === 'json') {
             console.log(JSON.stringify({
               valid: false,
               errors: parseResult.errors
             }, null, 2));
           } else {
             console.error(formatParseErrors(parseResult.errors, source, filePath, { color }));
           }
           return { valid: false, errorCount: parseResult.errors.length, warningCount: 0 };
         }

         // Validate
         const validationResult = validate(parseResult.ast);

         if (format === 'json') {
           console.log(JSON.stringify({
             valid: validationResult.valid,
             errors: validationResult.errors,
             warnings: validationResult.warnings
           }, null, 2));
         } else {
           if (validationResult.valid && validationResult.warnings.length === 0) {
             console.log(color
               ? chalk.green(`${filePath}: valid`)
               : `${filePath}: valid`
             );
           } else if (validationResult.valid) {
             console.log(formatValidationResult(validationResult, parseResult.ast.sourceMap, { color }));
             console.log(color
               ? chalk.green(`${filePath}: valid (with warnings)`)
               : `${filePath}: valid (with warnings)`
             );
           } else {
             console.error(formatValidationResult(validationResult, parseResult.ast.sourceMap, { color }));
           }
         }

         return {
           valid: validationResult.valid,
           errorCount: validationResult.errors.length,
           warningCount: validationResult.warnings.length
         };
       }
       ```

    2. Create src/cli/index.ts as the CLI entry point:
       ```typescript
       #!/usr/bin/env bun
       import { Command } from 'commander';
       import { validateFile } from './validate';

       const program = new Command();

       program
         .name('flowscript')
         .description('Text-native workflow engine - execute .flow.md files as programs')
         .version('0.1.0');

       program
         .command('validate')
         .description('Validate a workflow file without executing')
         .argument('<file>', 'Path to .flow.md file')
         .option('--format <type>', 'Output format: text, json', 'text')
         .option('--no-color', 'Disable colored output')
         .action(async (file: string, options: { format?: string; color?: boolean }) => {
           const result = await validateFile(file, {
             format: options.format as 'text' | 'json',
             color: options.color !== false
           });

           process.exit(result.valid ? 0 : 1);
         });

       program.parse();
       ```

    3. Update package.json bin field (should already be set from Plan 01, verify):
       ```json
       {
         "bin": {
           "flowscript": "./src/cli/index.ts"
         }
       }
       ```
  </action>
  <verify>
    ```bash
    # 1. TypeScript compiles
    bun run typecheck

    # 2. CLI runs and shows help
    bun src/cli/index.ts --help

    # 3. Validate command shows help
    bun src/cli/index.ts validate --help

    # 4. Test with valid file
    cat > /tmp/valid.flow.md << 'EOF'
    ---
    name: test-workflow
    version: 1.0.0
    ---
    <source id="fetch" type="http">
      <url>https://example.com</url>
    </source>
    EOF
    bun src/cli/index.ts validate /tmp/valid.flow.md
    echo "Exit code: $?"  # Should be 0

    # 5. Test with invalid file (undefined reference)
    cat > /tmp/invalid.flow.md << 'EOF'
    ---
    name: test-workflow
    version: 1.0.0
    ---
    <source id="fetch" type="http">
      <url>https://example.com</url>
    </source>
    <transform id="process" type="template" input="nonexistent">
      <template>{{input}}</template>
    </transform>
    EOF
    bun src/cli/index.ts validate /tmp/invalid.flow.md
    echo "Exit code: $?"  # Should be 1
    ```
  </verify>
  <done>
    - src/cli/validate.ts implements validateFile() function
    - src/cli/index.ts provides CLI entry point with commander
    - `flowscript validate <file>` works and shows pass/fail
    - Exit code 0 on valid, 1 on invalid
    - Errors display with source context and line numbers
  </done>
</task>

</tasks>

<verification>
Run these commands to verify the plan completed successfully:

```bash
# 1. TypeScript compiles
bun run typecheck

# 2. CLI shows help
bun src/cli/index.ts --help
bun src/cli/index.ts validate --help

# 3. Valid workflow passes validation
cat > /tmp/valid.flow.md << 'EOF'
---
name: test-workflow
version: 1.0.0
secrets:
  - API_KEY
---
<source id="fetch" type="http">
  <url>https://api.example.com</url>
  <headers>
    <Authorization>Bearer {{$secrets.API_KEY}}</Authorization>
  </headers>
</source>
<transform id="process" type="template" input="fetch">
  <template>Result: {{input.data}}</template>
</transform>
EOF
bun src/cli/index.ts validate /tmp/valid.flow.md && echo "PASS: Valid file accepted"

# 4. Undefined node reference fails validation
cat > /tmp/undef-ref.flow.md << 'EOF'
---
name: test
version: 1.0.0
---
<transform id="process" type="template" input="nonexistent">
  <template>{{input}}</template>
</transform>
EOF
bun src/cli/index.ts validate /tmp/undef-ref.flow.md || echo "PASS: Undefined ref caught"

# 5. Undeclared secret fails validation
cat > /tmp/undef-secret.flow.md << 'EOF'
---
name: test
version: 1.0.0
---
<source id="fetch" type="http">
  <headers>
    <Authorization>{{$secrets.UNDECLARED}}</Authorization>
  </headers>
</source>
EOF
bun src/cli/index.ts validate /tmp/undef-secret.flow.md || echo "PASS: Undeclared secret caught"

# 6. Duplicate ID fails validation
cat > /tmp/dup-id.flow.md << 'EOF'
---
name: test
version: 1.0.0
---
<source id="fetch" type="http"/>
<source id="fetch" type="file"/>
EOF
bun src/cli/index.ts validate /tmp/dup-id.flow.md || echo "PASS: Duplicate ID caught"

# 7. Circular dependency fails validation
cat > /tmp/circular.flow.md << 'EOF'
---
name: test
version: 1.0.0
---
<transform id="a" type="template" input="b"/>
<transform id="b" type="template" input="a"/>
EOF
bun src/cli/index.ts validate /tmp/circular.flow.md || echo "PASS: Circular dependency caught"
```

All tests should show appropriate PASS messages.
</verification>

<success_criteria>
- [ ] `bun run typecheck` passes with no errors
- [ ] `flowscript validate <file>` runs and returns pass/fail
- [ ] Validator catches missing required fields with line numbers
- [ ] Validator catches undefined node references with suggestions
- [ ] Validator catches undeclared secrets
- [ ] Validator catches duplicate node IDs
- [ ] Validator detects circular dependencies and shows cycle path
- [ ] CLI displays errors with source code context (@babel/code-frame)
- [ ] CLI exits with code 0 on valid, code 1 on invalid
- [ ] JSON output format works (--format json)
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-03-SUMMARY.md`
</output>
