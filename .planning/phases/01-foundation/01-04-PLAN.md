---
phase: 01-foundation
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - src/validator/references.ts
  - src/validator/references.test.ts
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Validator catches undeclared secrets and reports which are missing"
    - "Secret references in XML child elements (headers, url, body) are detected"
    - "Secret references using {{$secrets.NAME}} syntax are detected"
  artifacts:
    - src/validator/references.ts
    - src/validator/references.test.ts
  key_links:
    - "validateSecretReferences extracts from raw XML source, not just config"
    - "Regex matches {{$secrets.NAME}} pattern variant"
---

<objective>
Fix secret reference validation to detect undeclared secrets in workflow files.

Purpose: Close verification gap - files using undeclared secrets currently pass validation when they should fail.
Output: Working secret validation with test coverage.
</objective>

<execution_context>
@/Users/narcisbrindusescu/.claude/looppool/workflows/execute-plan.md
@/Users/narcisbrindusescu/.claude/looppool/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/01-foundation/01-VERIFICATION.md

Key insight from verification:
- The current validateSecretReferences only checks node.config (XML attributes)
- Secret references appear in XML child elements like <headers>, <url>, <body>
- The regex pattern is `\$?\{\{secrets\.(\w+)\}\}` but actual usage is `{{$secrets.NAME}}`
- Need to either: (a) extract secret refs from raw XML source, OR (b) parse XML children into searchable structure

Approach: Search the raw source (sourceMap.source) for secret reference patterns.
This is simpler and catches secrets anywhere in the file.
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix secret reference regex pattern</name>
  <files>src/validator/references.ts</files>
  <action>
Update the checkSecretRefs function to handle the correct pattern:

1. The current pattern `\$?\{\{secrets\.(\w+)\}\}` expects `{{secrets.NAME}}` or `${{secrets.NAME}}`
2. The actual usage in test is `{{$secrets.NAME}}` (dollar sign INSIDE the braces)
3. Update regex to: `/\{\{\$secrets\.(\w+)\}\}/g`

Also update validateSecretReferences to search the raw source instead of just config:
- Accept sourceMap as additional parameter
- Use regex to find all `{{$secrets.NAME}}` patterns in sourceMap.source
- Cross-reference against declaredSecrets
- Report errors with approximate source location
  </action>
  <verify>bun run typecheck && bun test src/validator/references.test.ts</verify>
  <done>Regex pattern matches {{$secrets.NAME}} format</done>
</task>

<task type="auto">
  <name>Task 2: Update validateReferences to pass source</name>
  <files>src/validator/references.ts</files>
  <action>
Modify the validateReferences function to wire the source through to secret validation:

1. In validateReferences(ast: WorkflowAST), get the raw source: `ast.sourceMap.source`
2. Change the call from `validateSecretReferences(ast.nodes, declaredSecrets)` to `validateSecretReferences(ast.sourceMap.source, declaredSecrets)`
3. The validateSecretReferences function now receives the raw source string instead of nodes

Implementation detail:
```typescript
// BEFORE (in validateReferences):
const secretErrors = validateSecretReferences(ast.nodes, declaredSecrets);

// AFTER (in validateReferences):
const secretErrors = validateSecretReferences(ast.sourceMap.source, declaredSecrets);
```

This wiring change allows secret validation to scan the entire source for patterns rather than only checking node.config attributes.
  </action>
  <verify>bun run typecheck && bun test src/validator/references.test.ts</verify>
  <done>validateReferences passes ast.sourceMap.source to validateSecretReferences</done>
</task>

<task type="auto">
  <name>Task 3: Add test coverage for secret validation</name>
  <files>src/validator/references.test.ts</files>
  <action>
Add test cases for secret reference validation:

1. Test: Undeclared secret in HTTP source headers
```typescript
test('detects undeclared secret in source node', () => {
  const source = `---
name: test
version: 1.0.0
---
<workflow>
  <source id="fetch" type="http">
    <headers>
      <Authorization>Bearer {{$secrets.UNDECLARED}}</Authorization>
    </headers>
  </source>
</workflow>`;

  const result = parse(source);
  // ... validate and check for VALID_UNDEFINED_SECRET_REF error
});
```

2. Test: Declared secret passes validation
3. Test: Multiple undeclared secrets all reported
4. Test: Secret in transform template detected
  </action>
  <verify>bun test src/validator/references.test.ts</verify>
  <done>All secret validation tests pass</done>
</task>

</tasks>

<verification>
```bash
# Test undeclared secret detection
cat > /tmp/undeclared-secret.flow.md << 'EOF'
---
name: test
version: 1.0.0
---
<workflow>
  <source id="fetch" type="http">
    <headers>
      <Authorization>Bearer {{$secrets.UNDECLARED}}</Authorization>
    </headers>
  </source>
</workflow>
EOF

bun src/cli/index.ts validate /tmp/undeclared-secret.flow.md
# Should exit 1 with error about undeclared secret

# Test declared secret passes
cat > /tmp/declared-secret.flow.md << 'EOF'
---
name: test
version: 1.0.0
secrets:
  - API_KEY
---
<workflow>
  <source id="fetch" type="http">
    <headers>
      <Authorization>Bearer {{$secrets.API_KEY}}</Authorization>
    </headers>
  </source>
</workflow>
EOF

bun src/cli/index.ts validate /tmp/declared-secret.flow.md
# Should exit 0
```
</verification>

<success_criteria>
- [ ] `bun src/cli/index.ts validate /tmp/undeclared-secret.flow.md` exits 1
- [ ] Error message mentions "UNDECLARED" secret
- [ ] `bun src/cli/index.ts validate /tmp/declared-secret.flow.md` exits 0
- [ ] `bun test src/validator/references.test.ts` passes
- [ ] `bun run typecheck` passes
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-04-SUMMARY.md`
</output>
