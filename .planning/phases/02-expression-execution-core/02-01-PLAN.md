---
phase: 02-expression-execution-core
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/expression/types.ts
  - src/expression/parser.ts
  - src/expression/evaluator.ts
  - src/expression/index.ts
  - package.json
autonomous: true

must_haves:
  truths:
    - "Template expressions like {{value}} are extracted from text correctly"
    - "jsep parses expressions into AST nodes"
    - "Evaluator handles Literal, Identifier, MemberExpression, BinaryExpression, UnaryExpression, ConditionalExpression"
    - "Access to __proto__, constructor, prototype throws ExpressionError"
    - "Only whitelisted function calls are allowed"
    - "Expression errors include expression text and position"
  artifacts:
    - src/expression/types.ts
    - src/expression/parser.ts
    - src/expression/evaluator.ts
    - src/expression/index.ts
  key_links:
    - "parser.ts extracts {{...}} segments and uses jsep"
    - "evaluator.ts walks jsep AST nodes"
    - "index.ts exports evaluate() as main entry point"
---

<objective>
Build the core expression parsing and sandboxed evaluation engine

Purpose: Enable template expressions like `{{node.output.field}}` to be safely parsed and evaluated without code injection vulnerabilities. This is the foundation for all dynamic data flow in FlowScript.

Output: Expression module with parser (template extraction + jsep), sandboxed AST-walking evaluator, and expression-specific types including ExpressionError.
</objective>

<execution_context>
@/Users/narcisbrindusescu/.claude/looppool/workflows/execute-plan.md
@/Users/narcisbrindusescu/.claude/looppool/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-expression-execution-core/02-RESEARCH.md

# Existing types to extend
@src/types/errors.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install dependencies and create expression types</name>
  <files>package.json, src/expression/types.ts</files>
  <action>
1. Install jsep for expression parsing:
   ```bash
   bun add jsep
   ```

2. Create `src/expression/types.ts` with:
   - `TemplateSegment` interface: `{ type: 'text' | 'expression'; value: string; start: number; end: number }`
   - `EvalContext` interface: `{ variables: Record<string, unknown>; functions: Record<string, Function> }`
   - `ExpressionError` class extending Error with:
     - `expression?: string` - the expression that failed
     - `template?: string` - the full template string (if in template context)
     - `position?: { start: number; end: number }` - position in template
     - `cause?: unknown` - underlying error
   - Re-export jsep types needed: `jsep.Expression`

Note: Use `declare module 'jsep'` if types are missing, or jsep may have built-in types.
  </action>
  <verify>bun run --bun -e "import { ExpressionError } from './src/expression/types'; console.log('Types OK')"</verify>
  <done>Expression types compile, ExpressionError can be constructed with context</done>
</task>

<task type="auto">
  <name>Task 2: Implement template parser with jsep</name>
  <files>src/expression/parser.ts</files>
  <action>
1. Create `src/expression/parser.ts` with:

2. `extractTemplateSegments(template: string): TemplateSegment[]`
   - Use regex `/\{\{(.+?)\}\}/g` to find expression boundaries
   - Return array of segments (text and expression) with positions
   - Handle edge cases: empty template, no expressions, consecutive expressions

3. `parseExpression(expr: string): jsep.Expression`
   - Configure jsep: Remove bitwise operators (not needed in workflows):
     ```typescript
     jsep.removeBinaryOp('>>>');
     jsep.removeBinaryOp('>>');
     jsep.removeBinaryOp('<<');
     jsep.removeBinaryOp('|');
     jsep.removeBinaryOp('^');
     jsep.removeBinaryOp('&');
     ```
   - Add nullish coalescing: `jsep.addBinaryOp('??', 1);`
   - Wrap jsep() call in try/catch, throw ExpressionError on parse failure

4. Export both functions
  </action>
  <verify>bun test src/expression/parser.test.ts</verify>
  <done>Parser extracts segments correctly, jsep parses expressions to AST</done>
</task>

<task type="auto">
  <name>Task 3: Implement sandboxed AST-walking evaluator</name>
  <files>src/expression/evaluator.ts, src/expression/index.ts</files>
  <action>
1. Create `src/expression/evaluator.ts` with:

2. `const BLOCKED_PROPS = new Set(['__proto__', 'constructor', 'prototype'])`

3. `evaluateNode(node: jsep.Expression, context: EvalContext): unknown`
   Recursive AST walker handling:
   - `Literal`: return `node.value`
   - `Identifier`: return `context.variables[node.name]` (undefined if missing, like bcx-expression-evaluator)
   - `MemberExpression`:
     - Evaluate object, check if null/undefined (return undefined)
     - Get property name (computed vs non-computed)
     - **SECURITY**: Throw ExpressionError if prop in BLOCKED_PROPS
     - Return property value
   - `CallExpression`:
     - **SECURITY**: Only allow `Identifier` callee (no method calls on objects)
     - Look up function in `context.functions`
     - Throw ExpressionError if function not found
     - Evaluate arguments, call function
   - `BinaryExpression`: Implement operators +, -, *, /, %, ==, ===, !=, !==, <, >, <=, >=, &&, ||, ??
   - `UnaryExpression`: Implement !, -, +
   - `ConditionalExpression`: Evaluate test, return consequent or alternate
   - `ArrayExpression`: Evaluate all elements, return array
   - `ObjectExpression`: Evaluate all properties, return object (jsep plugin may be needed)
   - Default: throw ExpressionError for unsupported node type

4. `evaluate(expression: string, context: EvalContext): unknown`
   - Parse with parseExpression()
   - Evaluate with evaluateNode()
   - Wrap errors to include expression context

5. Create `src/expression/index.ts`:
   - Export `evaluate`, `evaluateNode` from evaluator
   - Export `extractTemplateSegments`, `parseExpression` from parser
   - Export types from types.ts
   - Create `evaluateTemplate(template: string, context: EvalContext): string`
     - Extract segments
     - For each expression segment, evaluate and convert to string
     - Concatenate results
  </action>
  <verify>bun test src/expression/evaluator.test.ts</verify>
  <done>Evaluator handles all node types, blocks prototype access, rejects unknown functions</done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Unit tests pass:
   ```bash
   bun test src/expression/
   ```

2. Security verification - these should throw ExpressionError:
   ```typescript
   evaluate('obj.__proto__', { variables: { obj: {} }, functions: {} });
   evaluate('obj.constructor', { variables: { obj: {} }, functions: {} });
   evaluate('unknownFn()', { variables: {}, functions: {} });
   evaluate('obj.method()', { variables: { obj: { method: () => {} } }, functions: {} });
   ```

3. Happy path works:
   ```typescript
   evaluate('a + b', { variables: { a: 1, b: 2 }, functions: {} }); // 3
   evaluate('user.name', { variables: { user: { name: 'Alice' } }, functions: {} }); // 'Alice'
   evaluate('x ?? "default"', { variables: { x: null }, functions: {} }); // 'default'
   evaluateTemplate('Hello {{name}}!', { variables: { name: 'World' }, functions: {} }); // 'Hello World!'
   ```
</verification>

<success_criteria>
- [ ] jsep installed and importable
- [ ] Template extraction handles edge cases (no expressions, consecutive, nested text)
- [ ] jsep configured without bitwise ops, with nullish coalescing
- [ ] Evaluator handles all standard AST node types
- [ ] Prototype access blocked (__proto__, constructor, prototype)
- [ ] Only whitelisted function calls allowed
- [ ] ExpressionError includes expression text and position
- [ ] evaluateTemplate() produces correct string output
- [ ] All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/02-expression-execution-core/02-01-SUMMARY.md`
</output>
