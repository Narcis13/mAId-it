---
phase: 02-expression-execution-core
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/expression/functions/index.ts
  - src/expression/functions/string.ts
  - src/expression/functions/array.ts
  - src/expression/functions/math.ts
  - src/expression/functions/time.ts
  - src/expression/functions/object.ts
  - src/expression/functions/type.ts
  - package.json
autonomous: true

must_haves:
  truths:
    - "String functions work: upper, lower, trim, replace, split, join, truncate"
    - "Array functions work: length, first, last, slice, flatten, unique, sort"
    - "Math functions work: min, max, sum, avg, round, floor, ceil, abs, random, random_int"
    - "Time functions work: now, date, parse_date, add_time"
    - "Object functions work: keys, values, entries, get, merge, pick, omit"
    - "Type functions work: typeof, is_null, is_array, is_object, to_string, to_number, to_boolean"
    - "All functions handle null/undefined inputs gracefully"
  artifacts:
    - src/expression/functions/index.ts
    - src/expression/functions/string.ts
    - src/expression/functions/array.ts
    - src/expression/functions/math.ts
    - src/expression/functions/time.ts
    - src/expression/functions/object.ts
    - src/expression/functions/type.ts
  key_links:
    - "index.ts exports getBuiltinFunctions() returning Record<string, Function>"
    - "Each category file exports individual functions"
---

<objective>
Build the built-in functions library for expression evaluation

Purpose: Provide a curated set of safe functions (string, array, math, time, object, type) that expressions can call. These functions enable data transformation within workflow expressions without allowing arbitrary code execution.

Output: Functions module with categorized implementations and a central registry that returns all built-in functions as a Record<string, Function>.
</objective>

<execution_context>
@/Users/narcisbrindusescu/.claude/looppool/workflows/execute-plan.md
@/Users/narcisbrindusescu/.claude/looppool/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-expression-execution-core/02-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install Luxon and create string/array functions</name>
  <files>package.json, src/expression/functions/string.ts, src/expression/functions/array.ts</files>
  <action>
1. Install Luxon for date/time operations:
   ```bash
   bun add luxon
   bun add -d @types/luxon
   ```

2. Create `src/expression/functions/string.ts`:
   ```typescript
   export const stringFunctions = {
     upper: (s: string) => String(s ?? '').toUpperCase(),
     lower: (s: string) => String(s ?? '').toLowerCase(),
     trim: (s: string) => String(s ?? '').trim(),
     replace: (s: string, old: string, repl: string) => String(s ?? '').replaceAll(old, repl),
     split: (s: string, delim: string) => String(s ?? '').split(delim),
     join: (arr: unknown[], delim: string) => (arr ?? []).join(delim),
     truncate: (s: string, len: number, suffix = '...') => {
       const str = String(s ?? '');
       return str.length > len ? str.slice(0, len - suffix.length) + suffix : str;
     },
     concat: (...args: string[]) => args.map(a => String(a ?? '')).join(''),
     includes: (s: string, search: string) => String(s ?? '').includes(search),
     starts_with: (s: string, prefix: string) => String(s ?? '').startsWith(prefix),
     ends_with: (s: string, suffix: string) => String(s ?? '').endsWith(suffix),
     substring: (s: string, start: number, end?: number) => String(s ?? '').substring(start, end),
     pad_start: (s: string, len: number, fill = ' ') => String(s ?? '').padStart(len, fill),
     pad_end: (s: string, len: number, fill = ' ') => String(s ?? '').padEnd(len, fill),
   };
   ```

3. Create `src/expression/functions/array.ts`:
   ```typescript
   export const arrayFunctions = {
     length: (arr: unknown[] | string) => (arr ?? []).length,
     first: (arr: unknown[]) => (arr ?? [])[0],
     last: (arr: unknown[]) => { const a = arr ?? []; return a[a.length - 1]; },
     slice: (arr: unknown[], start: number, end?: number) => (arr ?? []).slice(start, end),
     flatten: (arr: unknown[]) => (arr ?? []).flat(),
     unique: (arr: unknown[]) => [...new Set(arr ?? [])],
     reverse: (arr: unknown[]) => [...(arr ?? [])].reverse(),
     contains: (arr: unknown[], item: unknown) => (arr ?? []).includes(item),
     index_of: (arr: unknown[], item: unknown) => (arr ?? []).indexOf(item),
     sort: (arr: unknown[], key?: string, dir: 'asc' | 'desc' = 'asc') => {
       const sorted = [...(arr ?? [])].sort((a, b) => {
         const va = key ? (a as Record<string, unknown>)?.[key] : a;
         const vb = key ? (b as Record<string, unknown>)?.[key] : b;
         if (va === vb) return 0;
         if (va === null || va === undefined) return 1;
         if (vb === null || vb === undefined) return -1;
         return va < vb ? -1 : 1;
       });
       return dir === 'desc' ? sorted.reverse() : sorted;
     },
     compact: (arr: unknown[]) => (arr ?? []).filter(x => x !== null && x !== undefined),
     count: (arr: unknown[], predicate?: (item: unknown) => boolean) =>
       predicate ? (arr ?? []).filter(predicate).length : (arr ?? []).length,
   };
   ```
  </action>
  <verify>bun run --bun -e "import { stringFunctions } from './src/expression/functions/string'; import { arrayFunctions } from './src/expression/functions/array'; console.log(stringFunctions.upper('hello'), arrayFunctions.length([1,2,3]))"</verify>
  <done>String and array functions work, handle null/undefined</done>
</task>

<task type="auto">
  <name>Task 2: Create math, time, and object functions</name>
  <files>src/expression/functions/math.ts, src/expression/functions/time.ts, src/expression/functions/object.ts</files>
  <action>
1. Create `src/expression/functions/math.ts`:
   ```typescript
   export const mathFunctions = {
     min: (...args: number[]) => Math.min(...args.filter(n => typeof n === 'number')),
     max: (...args: number[]) => Math.max(...args.filter(n => typeof n === 'number')),
     sum: (arr: number[]) => (arr ?? []).reduce((a, b) => a + (Number(b) || 0), 0),
     avg: (arr: number[]) => {
       const nums = (arr ?? []).filter(n => typeof n === 'number');
       return nums.length ? nums.reduce((a, b) => a + b, 0) / nums.length : 0;
     },
     round: (n: number, decimals = 0) => {
       const factor = 10 ** decimals;
       return Math.round((Number(n) || 0) * factor) / factor;
     },
     floor: (n: number) => Math.floor(Number(n) || 0),
     ceil: (n: number) => Math.ceil(Number(n) || 0),
     abs: (n: number) => Math.abs(Number(n) || 0),
     pow: (base: number, exp: number) => Math.pow(Number(base) || 0, Number(exp) || 0),
     sqrt: (n: number) => Math.sqrt(Number(n) || 0),
     random: () => Math.random(),
     random_int: (min: number, max: number) =>
       Math.floor(Math.random() * (max - min + 1)) + min,
     clamp: (n: number, min: number, max: number) =>
       Math.min(Math.max(Number(n) || 0, min), max),
   };
   ```

2. Create `src/expression/functions/time.ts`:
   ```typescript
   import { DateTime, Duration } from 'luxon';

   export const timeFunctions = {
     now: () => DateTime.now().toISO(),
     date: (format?: string) => {
       const dt = DateTime.now();
       return format ? dt.toFormat(format) : dt.toISODate();
     },
     time: (format?: string) => {
       const dt = DateTime.now();
       return format ? dt.toFormat(format) : dt.toISOTime();
     },
     parse_date: (str: string, format?: string) => {
       if (!str) return null;
       const dt = format
         ? DateTime.fromFormat(str, format)
         : DateTime.fromISO(str);
       return dt.isValid ? dt.toISO() : null;
     },
     format_date: (isoDate: string, format: string) => {
       if (!isoDate) return null;
       const dt = DateTime.fromISO(isoDate);
       return dt.isValid ? dt.toFormat(format) : null;
     },
     add_time: (isoDate: string, duration: string | object) => {
       if (!isoDate) return null;
       const dt = DateTime.fromISO(isoDate);
       if (!dt.isValid) return null;
       const dur = typeof duration === 'string'
         ? Duration.fromISO(duration)
         : Duration.fromObject(duration as Record<string, number>);
       return dt.plus(dur).toISO();
     },
     subtract_time: (isoDate: string, duration: string | object) => {
       if (!isoDate) return null;
       const dt = DateTime.fromISO(isoDate);
       if (!dt.isValid) return null;
       const dur = typeof duration === 'string'
         ? Duration.fromISO(duration)
         : Duration.fromObject(duration as Record<string, number>);
       return dt.minus(dur).toISO();
     },
     diff: (date1: string, date2: string, unit: string = 'days') => {
       if (!date1 || !date2) return null;
       const dt1 = DateTime.fromISO(date1);
       const dt2 = DateTime.fromISO(date2);
       if (!dt1.isValid || !dt2.isValid) return null;
       return dt1.diff(dt2, unit as any).toObject()[unit];
     },
     timestamp: () => Date.now(),
     from_timestamp: (ts: number) => DateTime.fromMillis(ts).toISO(),
   };
   ```

3. Create `src/expression/functions/object.ts`:
   ```typescript
   export const objectFunctions = {
     keys: (obj: object) => Object.keys(obj ?? {}),
     values: (obj: object) => Object.values(obj ?? {}),
     entries: (obj: object) => Object.entries(obj ?? {}),
     from_entries: (entries: [string, unknown][]) => Object.fromEntries(entries ?? []),
     get: (obj: object, path: string, defaultValue?: unknown) => {
       if (!obj || !path) return defaultValue;
       const parts = path.split('.');
       let val: unknown = obj;
       for (const part of parts) {
         if (val === null || val === undefined) return defaultValue;
         val = (val as Record<string, unknown>)[part];
       }
       return val ?? defaultValue;
     },
     has: (obj: object, key: string) => obj != null && key in (obj as object),
     merge: (...objects: object[]) => Object.assign({}, ...objects.filter(o => o != null)),
     pick: (obj: object, keys: string[]) => {
       if (!obj) return {};
       return Object.fromEntries(
         (keys ?? []).filter(k => k in obj).map(k => [k, (obj as Record<string, unknown>)[k]])
       );
     },
     omit: (obj: object, keys: string[]) => {
       if (!obj) return {};
       const set = new Set(keys ?? []);
       return Object.fromEntries(
         Object.entries(obj).filter(([k]) => !set.has(k))
       );
     },
     size: (obj: object) => Object.keys(obj ?? {}).length,
   };
   ```
  </action>
  <verify>bun run --bun -e "import { mathFunctions } from './src/expression/functions/math'; import { timeFunctions } from './src/expression/functions/time'; import { objectFunctions } from './src/expression/functions/object'; console.log(mathFunctions.sum([1,2,3]), timeFunctions.now(), objectFunctions.keys({a:1}))"</verify>
  <done>Math, time, and object functions work correctly</done>
</task>

<task type="auto">
  <name>Task 3: Create type functions and central registry</name>
  <files>src/expression/functions/type.ts, src/expression/functions/index.ts</files>
  <action>
1. Create `src/expression/functions/type.ts`:
   ```typescript
   export const typeFunctions = {
     typeof: (val: unknown) => {
       if (val === null) return 'null';
       if (Array.isArray(val)) return 'array';
       return typeof val;
     },
     is_null: (val: unknown) => val === null || val === undefined,
     is_array: (val: unknown) => Array.isArray(val),
     is_object: (val: unknown) => typeof val === 'object' && val !== null && !Array.isArray(val),
     is_string: (val: unknown) => typeof val === 'string',
     is_number: (val: unknown) => typeof val === 'number' && !Number.isNaN(val),
     is_boolean: (val: unknown) => typeof val === 'boolean',
     is_empty: (val: unknown) => {
       if (val === null || val === undefined) return true;
       if (typeof val === 'string') return val.length === 0;
       if (Array.isArray(val)) return val.length === 0;
       if (typeof val === 'object') return Object.keys(val).length === 0;
       return false;
     },
     to_string: (val: unknown) => {
       if (val === null || val === undefined) return '';
       if (typeof val === 'object') return JSON.stringify(val);
       return String(val);
     },
     to_number: (val: unknown) => {
       const n = Number(val);
       return Number.isNaN(n) ? 0 : n;
     },
     to_boolean: (val: unknown) => Boolean(val),
     to_array: (val: unknown) => {
       if (Array.isArray(val)) return val;
       if (val === null || val === undefined) return [];
       return [val];
     },
     coalesce: (...args: unknown[]) => args.find(a => a !== null && a !== undefined),
     default: (val: unknown, defaultValue: unknown) =>
       (val === null || val === undefined) ? defaultValue : val,
     if_else: (condition: unknown, thenValue: unknown, elseValue: unknown) =>
       condition ? thenValue : elseValue,
   };
   ```

2. Create `src/expression/functions/index.ts`:
   ```typescript
   import { stringFunctions } from './string';
   import { arrayFunctions } from './array';
   import { mathFunctions } from './math';
   import { timeFunctions } from './time';
   import { objectFunctions } from './object';
   import { typeFunctions } from './type';

   // Additional utility functions
   const utilityFunctions = {
     // Encoding
     json_encode: (obj: unknown) => JSON.stringify(obj),
     json_decode: (s: string) => { try { return JSON.parse(s); } catch { return null; } },
     base64_encode: (s: string) => btoa(String(s ?? '')),
     base64_decode: (s: string) => { try { return atob(String(s ?? '')); } catch { return null; } },
     url_encode: (s: string) => encodeURIComponent(String(s ?? '')),
     url_decode: (s: string) => { try { return decodeURIComponent(String(s ?? '')); } catch { return s; } },

     // UUID
     uuid: () => crypto.randomUUID(),

     // Regex
     match: (s: string, pattern: string) => {
       try {
         const regex = new RegExp(pattern);
         const match = String(s ?? '').match(regex);
         return match ? match[0] : null;
       } catch { return null; }
     },
     test: (s: string, pattern: string) => {
       try {
         const regex = new RegExp(pattern);
         return regex.test(String(s ?? ''));
       } catch { return false; }
     },
   };

   /**
    * Get all built-in functions as a Record<string, Function>.
    * This is passed to the evaluator as the function context.
    */
   export function getBuiltinFunctions(): Record<string, Function> {
     return {
       ...stringFunctions,
       ...arrayFunctions,
       ...mathFunctions,
       ...timeFunctions,
       ...objectFunctions,
       ...typeFunctions,
       ...utilityFunctions,
     };
   }

   // Re-export individual function sets for testing
   export { stringFunctions, arrayFunctions, mathFunctions, timeFunctions, objectFunctions, typeFunctions };
   ```
  </action>
  <verify>bun test src/expression/functions/</verify>
  <done>All function categories implemented, getBuiltinFunctions() returns complete registry</done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Unit tests pass for all function categories:
   ```bash
   bun test src/expression/functions/
   ```

2. Registry completeness check:
   ```typescript
   const fns = getBuiltinFunctions();
   // Should have 60+ functions
   console.log(Object.keys(fns).length);
   ```

3. Null safety verification - none of these should throw:
   ```typescript
   stringFunctions.upper(null);
   arrayFunctions.length(undefined);
   mathFunctions.sum(null);
   timeFunctions.parse_date(null);
   objectFunctions.keys(undefined);
   ```

4. Integration readiness:
   ```typescript
   import { getBuiltinFunctions } from './src/expression/functions';
   const context = { variables: {}, functions: getBuiltinFunctions() };
   // Ready to pass to evaluator
   ```
</verification>

<success_criteria>
- [ ] Luxon installed and working
- [ ] String functions handle null/undefined inputs
- [ ] Array functions handle null/undefined inputs
- [ ] Math functions handle non-numeric inputs gracefully
- [ ] Time functions use Luxon correctly, handle invalid dates
- [ ] Object functions handle null/undefined safely
- [ ] Type checking functions work correctly
- [ ] getBuiltinFunctions() returns all functions
- [ ] All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/02-expression-execution-core/02-02-SUMMARY.md`
</output>
