---
phase: 02-expression-execution-core
plan: 03
type: execute
wave: 2
depends_on: ["02-01", "02-02"]
files_modified:
  - src/expression/context.ts
  - src/execution/types.ts
  - src/execution/state.ts
  - src/execution/index.ts
  - src/expression/index.ts
  - src/types/errors.ts
autonomous: true

must_haves:
  truths:
    - "Context hierarchy applies: node variables override phase override global"
    - "$config, $secrets, $context special prefixes work in expressions"
    - "Node outputs are tracked and accessible via nodeId.output syntax"
    - "Secret values are redacted in error messages"
    - "Expression errors show which expression failed with context"
    - "evaluateInContext() integrates context, functions, and node outputs"
  artifacts:
    - src/expression/context.ts
    - src/execution/types.ts
    - src/execution/state.ts
    - src/execution/index.ts
  key_links:
    - "context.ts buildEvaluationContext() creates EvalContext from ExecutionState"
    - "state.ts ExecutionState tracks nodeOutputs Map"
    - "execution/index.ts exports evaluateInContext() as main API"
    - "expression/index.ts updated to use functions from 02-02"
---

<objective>
Build context hierarchy and node output tracking for expression resolution

Purpose: Enable expressions to access the full execution context including $config, $secrets, $context variables, and outputs from previously executed nodes. This completes the expression evaluation system by integrating it with workflow execution state.

Output: Context management module with hierarchy merging, execution state tracking for node outputs, and the final evaluateInContext() API that integrates everything.
</objective>

<execution_context>
@/Users/narcisbrindusescu/.claude/looppool/workflows/execute-plan.md
@/Users/narcisbrindusescu/.claude/looppool/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-expression-execution-core/02-RESEARCH.md

# Prior plan outputs (from same phase)
@src/expression/types.ts
@src/expression/evaluator.ts
@src/expression/functions/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create execution state types and node output tracking</name>
  <files>src/execution/types.ts, src/execution/state.ts</files>
  <action>
1. Create `src/execution/types.ts`:
   ```typescript
   /**
    * Node execution result.
    */
   export interface NodeResult {
     status: 'success' | 'failed' | 'skipped';
     output?: unknown;
     error?: Error;
     duration: number;
     startedAt: number;
     completedAt: number;
   }

   /**
    * Execution state for a running workflow.
    */
   export interface ExecutionState {
     // Identity
     workflowId: string;
     runId: string;

     // Progress
     status: 'pending' | 'running' | 'completed' | 'failed' | 'cancelled';
     currentWave: number;

     // Timing
     startedAt: number;
     completedAt?: number;

     // Results
     nodeResults: Map<string, NodeResult>;

     // Context layers
     globalContext: Record<string, unknown>;
     phaseContext: Record<string, unknown>;
     nodeContext: Record<string, unknown>;

     // Config and secrets (from workflow metadata)
     config: Record<string, unknown>;
     secrets: Record<string, string>;
   }

   /**
    * Options for creating a new execution state.
    */
   export interface ExecutionStateOptions {
     workflowId: string;
     runId?: string;
     config?: Record<string, unknown>;
     secrets?: Record<string, string>;
     globalContext?: Record<string, unknown>;
   }
   ```

2. Create `src/execution/state.ts`:
   ```typescript
   import type { ExecutionState, ExecutionStateOptions, NodeResult } from './types';

   /**
    * Create a new execution state.
    */
   export function createExecutionState(options: ExecutionStateOptions): ExecutionState {
     return {
       workflowId: options.workflowId,
       runId: options.runId ?? crypto.randomUUID(),
       status: 'pending',
       currentWave: 0,
       startedAt: Date.now(),
       nodeResults: new Map(),
       globalContext: options.globalContext ?? {},
       phaseContext: {},
       nodeContext: {},
       config: options.config ?? {},
       secrets: options.secrets ?? {},
     };
   }

   /**
    * Record a node's execution result.
    */
   export function recordNodeResult(
     state: ExecutionState,
     nodeId: string,
     result: NodeResult
   ): void {
     state.nodeResults.set(nodeId, result);
   }

   /**
    * Get a node's output, or undefined if not yet executed.
    */
   export function getNodeOutput(state: ExecutionState, nodeId: string): unknown {
     const result = state.nodeResults.get(nodeId);
     return result?.status === 'success' ? result.output : undefined;
   }

   /**
    * Check if a node has been executed successfully.
    */
   export function hasNodeExecuted(state: ExecutionState, nodeId: string): boolean {
     const result = state.nodeResults.get(nodeId);
     return result?.status === 'success';
   }

   /**
    * Get all available node outputs as a Map.
    */
   export function getNodeOutputs(state: ExecutionState): Map<string, unknown> {
     const outputs = new Map<string, unknown>();
     for (const [nodeId, result] of state.nodeResults) {
       if (result.status === 'success') {
         outputs.set(nodeId, result.output);
       }
     }
     return outputs;
   }

   /**
    * Update phase context (called when entering a new phase).
    */
   export function setPhaseContext(state: ExecutionState, context: Record<string, unknown>): void {
     state.phaseContext = context;
   }

   /**
    * Update node context (called before evaluating node expressions).
    */
   export function setNodeContext(state: ExecutionState, context: Record<string, unknown>): void {
     state.nodeContext = context;
   }

   /**
    * Mark execution as started.
    */
   export function markRunning(state: ExecutionState): void {
     state.status = 'running';
   }

   /**
    * Mark execution as completed.
    */
   export function markCompleted(state: ExecutionState): void {
     state.status = 'completed';
     state.completedAt = Date.now();
   }

   /**
    * Mark execution as failed.
    */
   export function markFailed(state: ExecutionState): void {
     state.status = 'failed';
     state.completedAt = Date.now();
   }
   ```
  </action>
  <verify>bun run --bun -e "import { createExecutionState, recordNodeResult, getNodeOutput } from './src/execution/state'; const s = createExecutionState({ workflowId: 'test' }); recordNodeResult(s, 'node1', { status: 'success', output: { data: 123 }, duration: 100, startedAt: Date.now(), completedAt: Date.now() }); console.log(getNodeOutput(s, 'node1'))"</verify>
  <done>Execution state tracks node outputs correctly</done>
</task>

<task type="auto">
  <name>Task 2: Create context builder with hierarchy and secret redaction</name>
  <files>src/expression/context.ts, src/types/errors.ts</files>
  <action>
1. Create `src/expression/context.ts`:
   ```typescript
   import type { EvalContext } from './types';
   import type { ExecutionState } from '../execution/types';
   import { getBuiltinFunctions } from './functions';
   import { getNodeOutputs } from '../execution/state';

   /**
    * Build evaluation context from execution state.
    * Applies context hierarchy: node > phase > global
    * Adds special prefixes: $config, $secrets, $context
    * Makes node outputs available as nodeId.output
    */
   export function buildEvaluationContext(state: ExecutionState): EvalContext {
     const variables: Record<string, unknown> = {};

     // Layer 1: Global context (base)
     Object.assign(variables, state.globalContext);

     // Layer 2: Phase context (overrides global)
     Object.assign(variables, state.phaseContext);

     // Layer 3: Node context (overrides phase)
     Object.assign(variables, state.nodeContext);

     // Special prefixes
     variables['$config'] = state.config;
     variables['$secrets'] = state.secrets;
     variables['$context'] = {
       ...state.globalContext,
       ...state.phaseContext,
       ...state.nodeContext,
     };

     // Add node outputs as direct references (e.g., fetch.output -> { output: {...} })
     const outputs = getNodeOutputs(state);
     for (const [nodeId, output] of outputs) {
       variables[nodeId] = { output };
     }

     return {
       variables,
       functions: getBuiltinFunctions(),
     };
   }

   /**
    * Create a minimal evaluation context for standalone expression evaluation.
    */
   export function createEvalContext(
     variables: Record<string, unknown> = {},
     functions?: Record<string, Function>
   ): EvalContext {
     return {
       variables,
       functions: functions ?? getBuiltinFunctions(),
     };
   }

   /**
    * Redact secret values from context for safe logging/error messages.
    */
   export function redactSecrets(context: EvalContext): EvalContext {
     const secrets = context.variables['$secrets'];
     if (!secrets || typeof secrets !== 'object') {
       return context;
     }

     const redactedSecrets = Object.fromEntries(
       Object.keys(secrets as object).map(k => [k, '[REDACTED]'])
     );

     return {
       ...context,
       variables: {
         ...context.variables,
         '$secrets': redactedSecrets,
       },
     };
   }

   /**
    * Create a safe string representation of context for error messages.
    */
   export function contextToString(context: EvalContext): string {
     const redacted = redactSecrets(context);
     const keys = Object.keys(redacted.variables);

     // Show variable names only, not values (to avoid leaking data)
     return `{ variables: [${keys.join(', ')}], functions: [${Object.keys(redacted.functions).length} built-in] }`;
   }
   ```

2. Update `src/types/errors.ts` to add expression error codes:
   - Add to ErrorCode type:
     ```typescript
     // Expression errors
     | 'EXPR_PARSE_ERROR'
     | 'EXPR_EVAL_ERROR'
     | 'EXPR_UNDEFINED_VARIABLE'
     | 'EXPR_UNDEFINED_FUNCTION'
     | 'EXPR_BLOCKED_ACCESS'
     | 'EXPR_TYPE_ERROR'
     ```
  </action>
  <verify>bun run --bun -e "import { buildEvaluationContext, redactSecrets } from './src/expression/context'; import { createExecutionState } from './src/execution/state'; const s = createExecutionState({ workflowId: 'test', secrets: { API_KEY: 'secret123' } }); const ctx = buildEvaluationContext(s); console.log('Has secrets:', '\$secrets' in ctx.variables); const redacted = redactSecrets(ctx); console.log('Redacted:', redacted.variables['\$secrets'])"</verify>
  <done>Context builder creates proper hierarchy, secrets are redacted in error output</done>
</task>

<task type="auto">
  <name>Task 3: Create integrated evaluateInContext API and update exports</name>
  <files>src/execution/index.ts, src/expression/index.ts</files>
  <action>
1. Update `src/expression/index.ts` to integrate everything:
   ```typescript
   // Re-export core evaluation functions
   export { evaluate, evaluateNode } from './evaluator';
   export { extractTemplateSegments, parseExpression } from './parser';
   export { ExpressionError } from './types';
   export type { EvalContext, TemplateSegment } from './types';

   // Re-export context utilities
   export {
     buildEvaluationContext,
     createEvalContext,
     redactSecrets,
     contextToString,
   } from './context';

   // Re-export functions
   export { getBuiltinFunctions } from './functions';

   // Import for evaluateTemplate
   import { extractTemplateSegments } from './parser';
   import { evaluate } from './evaluator';
   import type { EvalContext } from './types';
   import { ExpressionError } from './types';

   /**
    * Evaluate a template string, replacing all {{...}} expressions with their values.
    */
   export function evaluateTemplate(template: string, context: EvalContext): string {
     const segments = extractTemplateSegments(template);
     const parts: string[] = [];

     for (const segment of segments) {
       if (segment.type === 'text') {
         parts.push(segment.value);
       } else {
         try {
           const result = evaluate(segment.value, context);
           // Convert result to string
           if (result === null || result === undefined) {
             parts.push('');
           } else if (typeof result === 'object') {
             parts.push(JSON.stringify(result));
           } else {
             parts.push(String(result));
           }
         } catch (error) {
           // Re-throw with template context
           if (error instanceof ExpressionError) {
             error.context.template = template;
             error.context.position = { start: segment.start, end: segment.end };
           }
           throw error;
         }
       }
     }

     return parts.join('');
   }
   ```

2. Create `src/execution/index.ts`:
   ```typescript
   import type { ExecutionState } from './types';
   import { buildEvaluationContext, redactSecrets, contextToString } from '../expression/context';
   import { evaluate, evaluateTemplate, ExpressionError } from '../expression';

   // Re-export types
   export type { ExecutionState, ExecutionStateOptions, NodeResult } from './types';

   // Re-export state management
   export {
     createExecutionState,
     recordNodeResult,
     getNodeOutput,
     hasNodeExecuted,
     getNodeOutputs,
     setPhaseContext,
     setNodeContext,
     markRunning,
     markCompleted,
     markFailed,
   } from './state';

   /**
    * Evaluate an expression in the context of a running workflow execution.
    * This is the main API for expression evaluation during workflow execution.
    *
    * @param expression - The expression to evaluate (without {{ }})
    * @param state - The current execution state
    * @returns The evaluated result
    * @throws ExpressionError with context on failure
    */
   export function evaluateInContext(expression: string, state: ExecutionState): unknown {
     const context = buildEvaluationContext(state);

     try {
       return evaluate(expression, context);
     } catch (error) {
       if (error instanceof ExpressionError) {
         // Add redacted context info for debugging
         error.message = `${error.message}\nContext: ${contextToString(redactSecrets(context))}`;
       }
       throw error;
     }
   }

   /**
    * Evaluate a template string in the context of a running workflow execution.
    *
    * @param template - The template string containing {{...}} expressions
    * @param state - The current execution state
    * @returns The evaluated template with expressions replaced
    * @throws ExpressionError with context on failure
    */
   export function evaluateTemplateInContext(template: string, state: ExecutionState): string {
     const context = buildEvaluationContext(state);

     try {
       return evaluateTemplate(template, context);
     } catch (error) {
       if (error instanceof ExpressionError) {
         error.message = `${error.message}\nContext: ${contextToString(redactSecrets(context))}`;
       }
       throw error;
     }
   }

   /**
    * Resolve a node output reference like "nodeId.output.field".
    * Convenience function for accessing node outputs.
    *
    * @param reference - The node output reference
    * @param state - The current execution state
    * @returns The resolved value
    * @throws ExpressionError if node not executed or path invalid
    */
   export function resolveNodeReference(reference: string, state: ExecutionState): unknown {
     // Use expression evaluation which already handles node.output syntax
     return evaluateInContext(reference, state);
   }
   ```
  </action>
  <verify>bun test src/execution/ && bun test src/expression/</verify>
  <done>evaluateInContext() works with full execution state, errors include context without secrets</done>
</task>

</tasks>

<verification>
After all tasks complete:

1. All tests pass:
   ```bash
   bun test src/expression/ src/execution/
   ```

2. Context hierarchy verification:
   ```typescript
   const state = createExecutionState({
     workflowId: 'test',
     globalContext: { env: 'prod', shared: 'global' },
   });
   setPhaseContext(state, { phase: 'gather', shared: 'phase' });
   setNodeContext(state, { node: 'fetch', shared: 'node' });

   // shared should be 'node' (most specific wins)
   evaluateInContext('shared', state); // 'node'
   evaluateInContext('env', state); // 'prod'
   evaluateInContext('phase', state); // 'gather'
   ```

3. Node output resolution:
   ```typescript
   recordNodeResult(state, 'fetch', {
     status: 'success',
     output: { data: [1, 2, 3] },
     duration: 100,
     startedAt: Date.now() - 100,
     completedAt: Date.now(),
   });

   evaluateInContext('fetch.output.data', state); // [1, 2, 3]
   evaluateInContext('length(fetch.output.data)', state); // 3
   ```

4. Secret redaction in errors:
   ```typescript
   const state = createExecutionState({
     workflowId: 'test',
     secrets: { API_KEY: 'super-secret-key' },
   });

   try {
     evaluateInContext('nonexistent.thing', state);
   } catch (e) {
     // Error message should NOT contain 'super-secret-key'
     // Error message SHOULD contain '$secrets' as a key
   }
   ```

5. Special prefix access:
   ```typescript
   evaluateInContext('$config.timeout', state); // from config
   evaluateInContext('$secrets.API_KEY', state); // from secrets
   evaluateInContext('$context.env', state); // merged context
   ```
</verification>

<success_criteria>
- [ ] ExecutionState type defined with all required fields
- [ ] Node output tracking works (record, get, has, getAll)
- [ ] Context hierarchy applies correctly (node > phase > global)
- [ ] $config, $secrets, $context prefixes work
- [ ] Node outputs accessible via nodeId.output syntax
- [ ] Secrets are redacted in all error messages
- [ ] evaluateInContext() integrates context and functions
- [ ] evaluateTemplateInContext() works for full templates
- [ ] Error codes added to types/errors.ts
- [ ] All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/02-expression-execution-core/02-03-SUMMARY.md`
</output>
