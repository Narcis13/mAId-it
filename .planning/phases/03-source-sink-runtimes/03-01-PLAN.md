---
phase: 03-source-sink-runtimes
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/runtimes/types.ts
  - src/runtimes/errors.ts
  - src/runtimes/index.ts
autonomous: true

must_haves:
  truths:
    - NodeRuntime interface exists with execute method signature
    - HttpError class has status, body, and isRetryable properties
    - FileError class exists for file operation failures
    - Runtime registry can look up runtimes by type string
  artifacts:
    - src/runtimes/types.ts
    - src/runtimes/errors.ts
    - src/runtimes/index.ts
  key_links:
    - NodeRuntime.execute receives ExecutionState from execution module
    - Error classes integrate with ErrorCode enum from types/errors.ts
---

<objective>
Create the runtime infrastructure: NodeRuntime interface, custom error classes (HttpError, FileError), and runtime registry pattern.

Purpose: Establishes the foundation that HTTP and File runtimes will implement. The NodeRuntime interface defines the contract for all runtime implementations.

Output: src/runtimes/ module with types, errors, and registry.
</objective>

<execution_context>
@/Users/narcisbrindusescu/.claude/looppool/workflows/execute-plan.md
@/Users/narcisbrindusescu/.claude/looppool/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-source-sink-runtimes/03-RESEARCH.md

Prior phase outputs:
@src/execution/types.ts (ExecutionState type)
@src/types/errors.ts (ErrorCode enum pattern)
@src/types/ast.ts (NodeAST, SourceNode, SinkNode types)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create NodeRuntime interface and config types</name>
  <files>src/runtimes/types.ts</files>
  <action>
Create the runtime types file with:

1. NodeRuntime interface with generic type parameters:
```typescript
interface NodeRuntime<TConfig = unknown, TInput = unknown, TOutput = unknown> {
  type: string;
  execute(params: {
    node: NodeAST;
    input: TInput;
    config: TConfig;
    state: ExecutionState;
  }): Promise<TOutput>;
  validate?(node: NodeAST): ValidationError[];
}
```

2. ExecutionParams type (the params object for execute)

3. RuntimeExecuteResult type for wrapping outputs:
```typescript
interface RuntimeExecuteResult<T = unknown> {
  output: T;
  metadata?: Record<string, unknown>;
}
```

4. HttpSourceConfig, HttpSinkConfig, FileSourceConfig, FileSinkConfig types based on research patterns

5. AuthConfig type for bearer/basic auth

Import ExecutionState from execution module, NodeAST from types/ast.
  </action>
  <verify>bun run --bun src/runtimes/types.ts (no syntax errors)</verify>
  <done>Types compile, NodeRuntime interface has execute method with state parameter</done>
</task>

<task type="auto">
  <name>Task 2: Create custom error classes</name>
  <files>src/runtimes/errors.ts</files>
  <action>
Create error classes:

1. HttpError class:
```typescript
class HttpError extends Error {
  constructor(
    message: string,
    public readonly status: number,
    public readonly body?: string
  ) {
    super(message);
    this.name = 'HttpError';
  }

  get isRetryable(): boolean {
    return this.status === 429 || (this.status >= 500 && this.status < 600);
  }
}
```

2. FileError class:
```typescript
class FileError extends Error {
  constructor(
    message: string,
    public readonly path?: string,
    public readonly code?: string
  ) {
    super(message);
    this.name = 'FileError';
  }
}
```

3. Add runtime-specific error codes to complement ErrorCode enum:
- RUNTIME_HTTP_ERROR
- RUNTIME_FILE_NOT_FOUND
- RUNTIME_FILE_WRITE_ERROR
- RUNTIME_PATH_TRAVERSAL
- RUNTIME_TIMEOUT

Export all error classes and types.
  </action>
  <verify>bun run --bun src/runtimes/errors.ts (no syntax errors)</verify>
  <done>HttpError.isRetryable returns true for 429 and 5xx, FileError has path property</done>
</task>

<task type="auto">
  <name>Task 3: Create runtime registry and module exports</name>
  <files>src/runtimes/index.ts</files>
  <action>
Create runtime registry:

1. RuntimeRegistry class:
```typescript
class RuntimeRegistry {
  private runtimes = new Map<string, NodeRuntime>();

  register(runtime: NodeRuntime): void {
    this.runtimes.set(runtime.type, runtime);
  }

  get(type: string): NodeRuntime | undefined {
    return this.runtimes.get(type);
  }

  has(type: string): boolean {
    return this.runtimes.has(type);
  }

  list(): string[] {
    return Array.from(this.runtimes.keys());
  }
}
```

2. Singleton instance: `export const runtimeRegistry = new RuntimeRegistry();`

3. Convenience function: `getRuntime(type: string): NodeRuntime`

4. Re-export all types and errors from the module

Note: HTTP and File runtimes will be registered in their respective implementation files (Plans 02 and 03).
  </action>
  <verify>bun test src/runtimes/ --run 2>/dev/null || bun run --bun src/runtimes/index.ts</verify>
  <done>Registry can register, get, has, and list runtimes. Module exports types and errors.</done>
</task>

</tasks>

<verification>
1. `bun run --bun src/runtimes/index.ts` - No syntax/import errors
2. `bun test` - All existing tests pass (no regressions)
3. Types are properly exported: NodeRuntime, HttpError, FileError, RuntimeRegistry
</verification>

<success_criteria>
- NodeRuntime interface defined with execute method accepting state
- HttpError has status, body, isRetryable
- FileError has path, code properties
- RuntimeRegistry singleton exported and functional
- All types properly exported from src/runtimes/index.ts
</success_criteria>

<output>
After completion, create `.planning/phases/03-source-sink-runtimes/03-01-SUMMARY.md`
</output>
