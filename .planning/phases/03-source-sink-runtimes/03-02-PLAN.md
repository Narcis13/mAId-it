---
phase: 03-source-sink-runtimes
plan: 02
type: execute
wave: 2
depends_on: [03-01]
files_modified:
  - src/runtimes/http/source.ts
  - src/runtimes/http/sink.ts
  - src/runtimes/http/index.ts
autonomous: true

must_haves:
  truths:
    - HTTP source makes GET requests with headers and query params
    - HTTP source makes POST requests with JSON body
    - HTTP source uses bearer token from $secrets for auth
    - HTTP source extracts response data via JMESPath expressions
    - HTTP sink posts workflow data to external endpoints
    - HTTP requests timeout after configurable duration (default 30s)
    - HTTP errors include status code and response body
  artifacts:
    - src/runtimes/http/source.ts
    - src/runtimes/http/sink.ts
    - src/runtimes/http/index.ts
  key_links:
    - HTTP runtimes register with RuntimeRegistry from 03-01
    - Bearer auth resolves $secrets via evaluateTemplateInContext
    - JMESPath extraction uses @jmespath-community/jmespath library
---

<objective>
Implement HTTP source and sink runtimes with full feature support: GET/POST methods, bearer authentication, query params, headers, JMESPath response extraction, and timeout handling.

Purpose: Enables workflows to fetch data from HTTP APIs (source) and send data to external endpoints (sink). Covers requirements HTTP-01 through HTTP-05.

Output: Complete HTTP runtime implementation in src/runtimes/http/
</objective>

<execution_context>
@/Users/narcisbrindusescu/.claude/looppool/workflows/execute-plan.md
@/Users/narcisbrindusescu/.claude/looppool/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-source-sink-runtimes/03-RESEARCH.md

Depends on Plan 01:
@src/runtimes/types.ts (NodeRuntime interface, HttpSourceConfig)
@src/runtimes/errors.ts (HttpError class)
@src/runtimes/index.ts (runtimeRegistry)

Phase 2 integration:
@src/execution/index.ts (evaluateTemplateInContext for resolving expressions)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install JMESPath and create HTTP source runtime</name>
  <files>src/runtimes/http/source.ts</files>
  <action>
First install JMESPath:
```bash
bun add @jmespath-community/jmespath
```

Then create HTTP source runtime:

1. Import types and utilities:
```typescript
import { search } from '@jmespath-community/jmespath';
import type { NodeRuntime, HttpSourceConfig } from '../types';
import { HttpError } from '../errors';
import { evaluateTemplateInContext } from '../../execution';
```

2. Implement HttpSourceRuntime class:
- type = 'http:source'
- execute() method that:
  a. Resolves template expressions in url, headers, params using evaluateTemplateInContext(value, state)
  b. Builds URL with query params using URL + URLSearchParams
  c. Builds auth headers (bearer from $secrets, basic)
  d. Makes fetch request with AbortSignal.timeout(config.timeout ?? 30000)
  e. Checks response.ok, throws HttpError with status and body if not
  f. Parses JSON response
  g. Applies JMESPath extraction if config.extract specified
  h. Returns extracted/full data

3. Helper function buildAuthHeaders(auth, state) for bearer/basic auth

4. Export the runtime instance

Handle edge cases:
- Non-JSON content-type: throw HttpError explaining expected JSON
- Timeout: AbortSignal.timeout handles this, error message is clear
- Network errors: let them bubble up as-is
  </action>
  <verify>bun run --bun src/runtimes/http/source.ts (no syntax errors)</verify>
  <done>HTTP source can make GET/POST with headers, params, bearer auth, and JMESPath extraction</done>
</task>

<task type="auto">
  <name>Task 2: Create HTTP sink runtime</name>
  <files>src/runtimes/http/sink.ts</files>
  <action>
Create HTTP sink runtime:

1. Import types:
```typescript
import type { NodeRuntime, HttpSinkConfig } from '../types';
import { HttpError } from '../errors';
import { evaluateTemplateInContext } from '../../execution';
```

2. Implement HttpSinkRuntime class:
- type = 'http:sink'
- execute() method that:
  a. Receives input data from previous node
  b. Resolves template expressions in url, headers
  c. Builds auth headers if configured
  d. Makes POST/PUT/PATCH request (default POST) with JSON.stringify(input) as body
  e. Sets Content-Type: application/json
  f. Uses AbortSignal.timeout(config.timeout ?? 30000)
  g. Checks response.ok, throws HttpError if not
  h. Returns { status, statusText, headers } as output

3. Export the runtime instance

The sink takes the input from the previous node and sends it as the request body.
  </action>
  <verify>bun run --bun src/runtimes/http/sink.ts (no syntax errors)</verify>
  <done>HTTP sink can POST data to endpoints with auth and timeout handling</done>
</task>

<task type="auto">
  <name>Task 3: Create HTTP module exports and register runtimes</name>
  <files>src/runtimes/http/index.ts</files>
  <action>
Create HTTP module entry point:

1. Import runtimes:
```typescript
import { httpSourceRuntime } from './source';
import { httpSinkRuntime } from './sink';
import { runtimeRegistry } from '../index';
```

2. Register both runtimes:
```typescript
runtimeRegistry.register(httpSourceRuntime);
runtimeRegistry.register(httpSinkRuntime);
```

3. Export everything:
```typescript
export { httpSourceRuntime } from './source';
export { httpSinkRuntime } from './sink';
```

4. Update src/runtimes/index.ts to import './http' (side effect import for registration)
  </action>
  <verify>bun test src/runtimes/ --run 2>/dev/null || bun run --bun src/runtimes/http/index.ts</verify>
  <done>HTTP runtimes registered, accessible via runtimeRegistry.get('http:source') and get('http:sink')</done>
</task>

</tasks>

<verification>
1. `bun run --bun src/runtimes/http/index.ts` - No syntax/import errors
2. `bun test` - All existing tests pass
3. Manually verify: `runtimeRegistry.get('http:source')` returns HttpSourceRuntime
4. Manually verify: `runtimeRegistry.get('http:sink')` returns HttpSinkRuntime
</verification>

<success_criteria>
- HTTP source supports GET and POST methods
- HTTP source resolves {{expressions}} in url/headers/params
- HTTP source extracts data with JMESPath (config.extract)
- HTTP source handles bearer auth from secrets
- HTTP sink posts input data as JSON body
- Both use AbortSignal.timeout for request timeout
- Both throw HttpError with status and body on failures
- Both runtimes registered in registry
</success_criteria>

<output>
After completion, create `.planning/phases/03-source-sink-runtimes/03-02-SUMMARY.md`
</output>
