---
phase: 03-source-sink-runtimes
plan: 03
type: execute
wave: 2
depends_on: [03-01]
files_modified:
  - src/runtimes/file/source.ts
  - src/runtimes/file/sink.ts
  - src/runtimes/file/path.ts
  - src/runtimes/file/index.ts
autonomous: true

must_haves:
  truths:
    - File source reads JSON files and parses content automatically
    - File source reads text files as string
    - File sink writes JSON data with pretty-printing
    - File sink writes text content to files
    - File paths support template expressions like {{config.outputDir}}/result.json
    - Path traversal attacks are blocked (no ../ or absolute paths)
    - Parent directories are created automatically when writing
  artifacts:
    - src/runtimes/file/source.ts
    - src/runtimes/file/sink.ts
    - src/runtimes/file/path.ts
    - src/runtimes/file/index.ts
  key_links:
    - File runtimes register with RuntimeRegistry from 03-01
    - Template paths resolved via evaluateTemplateInContext from execution module
    - Bun.file() and Bun.write() used for optimized file I/O
---

<objective>
Implement File source and sink runtimes with template path support, auto-format detection, JSON parsing, and security validation against path traversal.

Purpose: Enables workflows to read data from local files (source) and write results to files (sink). Covers requirements FILE-01 through FILE-05.

Output: Complete File runtime implementation in src/runtimes/file/
</objective>

<execution_context>
@/Users/narcisbrindusescu/.claude/looppool/workflows/execute-plan.md
@/Users/narcisbrindusescu/.claude/looppool/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-source-sink-runtimes/03-RESEARCH.md

Depends on Plan 01:
@src/runtimes/types.ts (NodeRuntime interface, FileSourceConfig, FileSinkConfig)
@src/runtimes/errors.ts (FileError class)
@src/runtimes/index.ts (runtimeRegistry)

Phase 2 integration:
@src/execution/index.ts (evaluateTemplateInContext for resolving path templates)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create path utilities with security validation</name>
  <files>src/runtimes/file/path.ts</files>
  <action>
Create path utilities:

1. Import dependencies:
```typescript
import { evaluateTemplateInContext } from '../../execution';
import { FileError } from '../errors';
import type { ExecutionState } from '../../execution';
```

2. resolveTemplatePath(template: string, state: ExecutionState): string
- Uses evaluateTemplateInContext to resolve {{expressions}}
- Validates result is a string
- Calls validatePath on result
- Returns resolved path

3. validatePath(path: string): void
- Normalize path (replace backslashes with forward slashes)
- Check for path traversal: if includes '../' or '..\\', throw FileError
- Check for absolute paths: if starts with '/' or matches Windows drive (C:\), throw FileError
- Error message: "Path traversal not allowed: {path}"

4. detectFormat(path: string): 'json' | 'text'
- Returns 'json' if path ends with '.json'
- Returns 'text' otherwise

Export all functions.

Security rationale: For v1, workflows can only access files relative to the working directory. Absolute paths and parent directory traversal are blocked to prevent reading/writing arbitrary system files.
  </action>
  <verify>bun run --bun src/runtimes/file/path.ts (no syntax errors)</verify>
  <done>Path utilities validate against traversal, resolve templates, detect format</done>
</task>

<task type="auto">
  <name>Task 2: Create File source runtime</name>
  <files>src/runtimes/file/source.ts</files>
  <action>
Create File source runtime:

1. Import types and utilities:
```typescript
import type { NodeRuntime, FileSourceConfig } from '../types';
import { FileError } from '../errors';
import { resolveTemplatePath, detectFormat } from './path';
```

2. Implement FileSourceRuntime class:
- type = 'file:source'
- execute() method that:
  a. Resolves config.path using resolveTemplatePath(config.path, state)
  b. Gets BunFile: `const file = Bun.file(resolvedPath);`
  c. Checks existence: `if (!(await file.exists())) throw new FileError("File not found: {path}", resolvedPath);`
  d. Determines format: `config.format ?? detectFormat(resolvedPath)`
  e. If format is 'json': `return file.json();` (optimized)
  f. Otherwise: `return file.text();`

3. Export the runtime instance

Key insight: Bun.file().json() is faster than .text() + JSON.parse() because it's combined and optimized in Zig.
  </action>
  <verify>bun run --bun src/runtimes/file/source.ts (no syntax errors)</verify>
  <done>File source reads JSON and text files with template path support</done>
</task>

<task type="auto">
  <name>Task 3: Create File sink runtime and module exports</name>
  <files>src/runtimes/file/sink.ts, src/runtimes/file/index.ts</files>
  <action>
Create File sink runtime (sink.ts):

1. Import dependencies:
```typescript
import { mkdir } from 'node:fs/promises';
import { dirname } from 'node:path';
import type { NodeRuntime, FileSinkConfig } from '../types';
import { FileError } from '../errors';
import { resolveTemplatePath } from './path';
```

2. Implement FileSinkRuntime class:
- type = 'file:sink'
- execute() method that:
  a. Resolves config.path using resolveTemplatePath(config.path, state)
  b. Creates parent directory if needed: `if (config.createDir !== false) await mkdir(dirname(resolvedPath), { recursive: true });`
  c. Determines content:
     - If format is 'json' OR input is object: `JSON.stringify(input, null, config.pretty !== false ? 2 : 0)`
     - Otherwise: `String(input)`
  d. Writes file: `const bytes = await Bun.write(resolvedPath, content);`
  e. Returns `{ path: resolvedPath, bytes }`

3. Export the runtime instance

Create module entry (index.ts):

1. Import runtimes:
```typescript
import { fileSourceRuntime } from './source';
import { fileSinkRuntime } from './sink';
import { runtimeRegistry } from '../index';
```

2. Register both runtimes with the registry

3. Export everything including path utilities:
```typescript
export { fileSourceRuntime } from './source';
export { fileSinkRuntime } from './sink';
export { resolveTemplatePath, validatePath, detectFormat } from './path';
```

4. Update src/runtimes/index.ts to import './file' (side effect import for registration)
  </action>
  <verify>bun test src/runtimes/ --run 2>/dev/null || bun run --bun src/runtimes/file/index.ts</verify>
  <done>File sink writes JSON/text with auto-directory creation, both runtimes registered</done>
</task>

</tasks>

<verification>
1. `bun run --bun src/runtimes/file/index.ts` - No syntax/import errors
2. `bun test` - All existing tests pass
3. Manually verify: `runtimeRegistry.get('file:source')` returns FileSourceRuntime
4. Manually verify: `runtimeRegistry.get('file:sink')` returns FileSinkRuntime
5. Path validation rejects '../secrets.json' and '/etc/passwd'
</verification>

<success_criteria>
- File source reads .json files as parsed JSON
- File source reads other files as text strings
- File sink writes objects as pretty JSON
- File sink writes strings as text
- File paths with {{expressions}} are resolved
- Path traversal blocked (../, absolute paths)
- Parent directories created automatically
- Both runtimes registered in registry
</success_criteria>

<output>
After completion, create `.planning/phases/03-source-sink-runtimes/03-03-SUMMARY.md`
</output>
