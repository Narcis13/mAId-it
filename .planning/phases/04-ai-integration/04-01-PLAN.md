---
phase: 04-ai-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/runtimes/ai/types.ts
  - src/runtimes/ai/errors.ts
  - src/runtimes/ai/retry.ts
autonomous: true

must_haves:
  truths:
    - "AiConfig interface defines model, systemPrompt, userPrompt, outputSchema, maxTokens, timeout, maxRetries"
    - "AiError and SchemaValidationError error classes follow established pattern from errors.ts"
    - "withRetry function implements full jitter exponential backoff"
    - "Retry-After header is respected when present"
  artifacts:
    - src/runtimes/ai/types.ts
    - src/runtimes/ai/errors.ts
    - src/runtimes/ai/retry.ts
  key_links:
    - "AiError extends Error with code field for categorization"
    - "SchemaValidationError includes original response and validation issues"
    - "withRetry accepts isRetryable predicate for flexible retry conditions"
---

<objective>
Create AI runtime infrastructure: type definitions, error classes, and retry utilities.

Purpose: Establish the foundation for AI runtime with typed config, specialized errors for AI failures and schema validation, and production-ready retry logic with exponential backoff and jitter.

Output: Three files (types.ts, errors.ts, retry.ts) in src/runtimes/ai/ following established patterns from http/file runtimes.
</objective>

<execution_context>
@/Users/narcisbrindusescu/.claude/looppool/workflows/execute-plan.md
@/Users/narcisbrindusescu/.claude/looppool/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-ai-integration/04-CONTEXT.md
@.planning/phases/04-ai-integration/04-RESEARCH.md

# Existing runtime patterns to follow
@src/runtimes/types.ts
@src/runtimes/errors.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create AI type definitions</name>
  <files>src/runtimes/ai/types.ts</files>
  <action>
Create `src/runtimes/ai/types.ts` with:

1. **AiConfig interface** for AI transform node configuration:
   ```typescript
   interface AiConfig {
     model: string;           // OpenRouter model ID: "anthropic/claude-3.5-sonnet"
     systemPrompt?: string;   // Template string with {{expressions}}
     userPrompt: string;      // Template string with {{expressions}}
     outputSchema?: string;   // TypeScript-like DSL: "{name: string, tags: string[]}"
     maxTokens?: number;      // Default: 4096
     timeout?: number;        // Default: 60000ms
     maxRetries?: number;     // Default: 3
   }
   ```

2. **OpenRouterRequest interface** for API requests:
   ```typescript
   interface OpenRouterRequest {
     model: string;
     messages: Array<{ role: 'system' | 'user' | 'assistant'; content: string }>;
     max_tokens?: number;
     response_format?: {
       type: 'json_schema';
       json_schema: {
         name: string;
         strict: boolean;
         schema: object;
       };
     };
   }
   ```

3. **OpenRouterResponse interface** for API responses:
   ```typescript
   interface OpenRouterResponse {
     id: string;
     choices: Array<{
       message: { role: string; content: string };
       finish_reason: string;
     }>;
     usage?: { prompt_tokens: number; completion_tokens: number; total_tokens: number };
   }
   ```

4. **AiResult interface** for runtime output:
   ```typescript
   interface AiResult<T = unknown> {
     output: T;
     usage?: { promptTokens: number; completionTokens: number; totalTokens: number };
   }
   ```

Follow established patterns: use `export interface`, add JSDoc comments, group related types with section comments.
  </action>
  <verify>bun --eval "import './src/runtimes/ai/types.ts'; console.log('Types compile OK')"</verify>
  <done>Types file exists with AiConfig, OpenRouterRequest, OpenRouterResponse, and AiResult interfaces</done>
</task>

<task type="auto">
  <name>Task 2: Create AI error classes</name>
  <files>src/runtimes/ai/errors.ts</files>
  <action>
Create `src/runtimes/ai/errors.ts` following established pattern from `src/runtimes/errors.ts`:

1. **Add error codes to RuntimeErrorCode type** (define locally, don't modify shared errors.ts):
   ```typescript
   type AiErrorCode =
     | 'AI_API_ERROR'          // OpenRouter API call failed
     | 'AI_RATE_LIMITED'       // 429 response
     | 'AI_SCHEMA_VALIDATION'  // Output didn't match schema
     | 'AI_TIMEOUT';           // Request timed out
   ```

2. **AiError class** for API failures:
   ```typescript
   class AiError extends Error {
     readonly code: AiErrorCode = 'AI_API_ERROR';
     constructor(
       message: string,
       public readonly status?: number,
       public readonly body?: string
     ) { ... }

     get isRetryable(): boolean {
       return this.status === 429 || (this.status !== undefined && this.status >= 500);
     }

     get isRateLimited(): boolean {
       return this.status === 429;
     }
   }
   ```

3. **SchemaValidationError class** for schema validation failures:
   ```typescript
   class SchemaValidationError extends Error {
     readonly code: AiErrorCode = 'AI_SCHEMA_VALIDATION';
     constructor(
       message: string,
       public readonly response: string,     // Raw AI response
       public readonly issues: Array<{       // Validation issues
         path: string;
         expected: string;
         received: string;
         message: string;
       }>
     ) { ... }
   }
   ```

All error classes must:
- Call `Object.setPrototypeOf(this, ClassName.prototype)` for proper prototype chain
- Set `this.name = 'ClassName'`
- Have JSDoc with examples
  </action>
  <verify>bun --eval "import { AiError, SchemaValidationError } from './src/runtimes/ai/errors.ts'; const e = new AiError('test', 429); console.log('isRetryable:', e.isRetryable, 'isRateLimited:', e.isRateLimited)"</verify>
  <done>Error classes exist with correct prototype chain, error codes, and retry logic</done>
</task>

<task type="auto">
  <name>Task 3: Create retry utility with exponential backoff</name>
  <files>src/runtimes/ai/retry.ts</files>
  <action>
Create `src/runtimes/ai/retry.ts` implementing full jitter exponential backoff (AWS pattern):

1. **RetryConfig interface**:
   ```typescript
   interface RetryConfig {
     maxAttempts: number;   // Default: 3
     baseDelay: number;     // Default: 1000ms
     maxDelay: number;      // Default: 32000ms
   }
   ```

2. **DEFAULT_RETRY_CONFIG constant**:
   ```typescript
   const DEFAULT_RETRY_CONFIG: RetryConfig = {
     maxAttempts: 3,
     baseDelay: 1000,
     maxDelay: 32000,
   };
   ```

3. **calculateJitteredDelay function** (full jitter algorithm):
   ```typescript
   function calculateJitteredDelay(
     attempt: number,
     config: RetryConfig,
     retryAfterMs?: number  // From Retry-After header
   ): number {
     // If server provided Retry-After, respect it
     if (retryAfterMs !== undefined) {
       return retryAfterMs;
     }
     // Full jitter: random(0, min(cap, base * 2^attempt))
     const exponentialDelay = config.baseDelay * Math.pow(2, attempt);
     const cappedDelay = Math.min(exponentialDelay, config.maxDelay);
     return Math.random() * cappedDelay;
   }
   ```

4. **parseRetryAfter function** to extract delay from response headers:
   ```typescript
   function parseRetryAfter(headers: Headers): number | undefined {
     const retryAfter = headers.get('Retry-After');
     if (!retryAfter) return undefined;

     // Handle seconds format
     const seconds = parseInt(retryAfter, 10);
     if (!isNaN(seconds)) return seconds * 1000;

     // Handle HTTP-date format
     const date = new Date(retryAfter);
     if (!isNaN(date.getTime())) {
       const delay = date.getTime() - Date.now();
       return delay > 0 ? delay : 0;
     }

     return undefined;
   }
   ```

5. **withRetry generic function**:
   ```typescript
   async function withRetry<T>(
     fn: () => Promise<T>,
     isRetryable: (error: unknown) => boolean,
     config: Partial<RetryConfig> = {},
     onRetry?: (attempt: number, error: unknown, delay: number) => void
   ): Promise<T> {
     const fullConfig = { ...DEFAULT_RETRY_CONFIG, ...config };
     let lastError: unknown;

     for (let attempt = 0; attempt < fullConfig.maxAttempts; attempt++) {
       try {
         return await fn();
       } catch (error) {
         lastError = error;

         if (!isRetryable(error) || attempt === fullConfig.maxAttempts - 1) {
           throw error;
         }

         const delay = calculateJitteredDelay(attempt, fullConfig);
         onRetry?.(attempt, error, delay);
         await new Promise(resolve => setTimeout(resolve, delay));
       }
     }

     throw lastError;
   }
   ```

Export: RetryConfig, DEFAULT_RETRY_CONFIG, calculateJitteredDelay, parseRetryAfter, withRetry
  </action>
  <verify>bun --eval "import { withRetry, calculateJitteredDelay, DEFAULT_RETRY_CONFIG } from './src/runtimes/ai/retry.ts'; const delay = calculateJitteredDelay(2, DEFAULT_RETRY_CONFIG); console.log('Jittered delay for attempt 2:', delay, 'ms (should be 0-4000)')"</verify>
  <done>Retry utility exists with full jitter backoff, Retry-After parsing, and generic withRetry function</done>
</task>

</tasks>

<verification>
```bash
# Verify all files exist and compile
bun --eval "
import './src/runtimes/ai/types.ts';
import './src/runtimes/ai/errors.ts';
import './src/runtimes/ai/retry.ts';
console.log('All AI infrastructure files compile successfully');
"

# Verify error retry logic
bun --eval "
import { AiError } from './src/runtimes/ai/errors.ts';
const e429 = new AiError('Rate limited', 429);
const e500 = new AiError('Server error', 500);
const e400 = new AiError('Bad request', 400);
console.log('429 retryable:', e429.isRetryable === true);
console.log('500 retryable:', e500.isRetryable === true);
console.log('400 retryable:', e400.isRetryable === false);
"

# Verify retry config defaults
bun --eval "
import { DEFAULT_RETRY_CONFIG } from './src/runtimes/ai/retry.ts';
console.log('Default config:', JSON.stringify(DEFAULT_RETRY_CONFIG));
"
```
</verification>

<success_criteria>
- [ ] src/runtimes/ai/types.ts exists with AiConfig, OpenRouterRequest, OpenRouterResponse, AiResult
- [ ] src/runtimes/ai/errors.ts exists with AiError, SchemaValidationError classes
- [ ] AiError.isRetryable returns true for 429 and 5xx status codes
- [ ] SchemaValidationError captures original response and validation issues
- [ ] src/runtimes/ai/retry.ts exists with withRetry, calculateJitteredDelay, parseRetryAfter
- [ ] Full jitter algorithm: delay = random(0, min(maxDelay, baseDelay * 2^attempt))
- [ ] Retry-After header is parsed and respected when present
- [ ] All files follow established codebase patterns (JSDoc, section comments, exports)
</success_criteria>

<output>
After completion, create `.planning/phases/04-ai-integration/04-01-SUMMARY.md`
</output>
