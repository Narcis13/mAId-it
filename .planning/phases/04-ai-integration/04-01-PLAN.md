---
phase: 04-ai-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/runtimes/ai/types.ts
  - src/runtimes/ai/errors.ts
  - src/runtimes/ai/retry.ts
autonomous: true

must_haves:
  truths:
    - AINodeConfig interface captures model, prompts, schema, tokens, retries, timeout
    - AIError class has code property (TIMEOUT, RATE_LIMIT, VALIDATION, API_ERROR)
    - SchemaValidationError stores failedOutput and validationMessage for retry prompts
    - calculateBackoffMs returns exponential delay with jitter capped at 32s
    - isRateLimitError detects 429 responses
  artifacts:
    - src/runtimes/ai/types.ts
    - src/runtimes/ai/errors.ts
    - src/runtimes/ai/retry.ts
  key_links:
    - AIError.isRetryable returns true for RATE_LIMIT and TIMEOUT codes
    - SchemaValidationError extends Error with Object.setPrototypeOf pattern
---

<objective>
Create AI infrastructure types, error classes, and retry utilities.

Purpose: Establish the foundation for AI runtime - typed configuration, error handling with retryable classification, and exponential backoff with jitter for rate limits.

Output: Three files in `src/runtimes/ai/` providing types, errors, and retry logic that the AI runtime will import.
</objective>

<execution_context>
@/Users/narcisbrindusescu/.claude/looppool/workflows/execute-plan.md
@/Users/narcisbrindusescu/.claude/looppool/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-ai-integration/04-CONTEXT.md
@.planning/phases/04-ai-integration/04-RESEARCH.md

<!-- Established patterns from Phase 3 -->
@src/runtimes/types.ts
@src/runtimes/errors.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create AI configuration types</name>
  <files>src/runtimes/ai/types.ts</files>
  <action>
Create `src/runtimes/ai/types.ts` with:

1. **AINodeConfig interface:**
   - `model: string` - OpenRouter model ID (e.g., "anthropic/claude-3.5-sonnet")
   - `systemPrompt: string` - System prompt (may contain template expressions)
   - `userPrompt: string` - User prompt (may contain template expressions)
   - `outputSchema: import('zod').ZodType` - Zod schema for output validation
   - `maxTokens?: number` - Output token limit (default 4096)
   - `maxRetries?: number` - Retry count on validation failure (default 3)
   - `timeout?: number` - Request timeout in ms (default 60000)

2. **AIResult interface:**
   - `output: T` - Generic typed output data
   - `usage: { inputTokens: number, outputTokens: number, totalCost: number }`
   - `retries: number` - Number of retries used

3. **AIErrorCode type:**
   - `'TIMEOUT' | 'RATE_LIMIT' | 'VALIDATION' | 'API_ERROR'`

Follow established pattern from `src/runtimes/types.ts` for documentation style.
  </action>
  <verify>bun run typecheck</verify>
  <done>AINodeConfig, AIResult, AIErrorCode types exported from types.ts</done>
</task>

<task type="auto">
  <name>Task 2: Create AI error classes</name>
  <files>src/runtimes/ai/errors.ts</files>
  <action>
Create `src/runtimes/ai/errors.ts` with:

1. **AIError class:**
   ```typescript
   class AIError extends Error {
     constructor(
       message: string,
       public readonly code: AIErrorCode,
       public readonly retryable: boolean
     ) {
       super(message);
       this.name = 'AIError';
       Object.setPrototypeOf(this, AIError.prototype);
     }

     get isRetryable(): boolean {
       return this.retryable;
     }
   }
   ```

2. **SchemaValidationError class:**
   ```typescript
   class SchemaValidationError extends Error {
     constructor(
       message: string,
       public readonly failedOutput: unknown,
       public readonly validationMessage: string
     ) {
       super(message);
       this.name = 'SchemaValidationError';
       Object.setPrototypeOf(this, SchemaValidationError.prototype);
     }
   }
   ```

3. **Helper function:** `isRateLimitError(error: unknown): boolean`
   - Check if error is HttpError with status 429
   - Check if error message contains "rate limit" (case insensitive)

Follow pattern from `src/runtimes/errors.ts` - use Object.setPrototypeOf for prototype chain.
  </action>
  <verify>bun run typecheck</verify>
  <done>AIError, SchemaValidationError classes and isRateLimitError helper exported</done>
</task>

<task type="auto">
  <name>Task 3: Create exponential backoff utility</name>
  <files>src/runtimes/ai/retry.ts</files>
  <action>
Create `src/runtimes/ai/retry.ts` with:

1. **calculateBackoffMs function:**
   ```typescript
   /**
    * Calculate exponential backoff with full jitter.
    * Uses AWS recommended "full jitter" strategy.
    *
    * @param attempt - Zero-based attempt number (0, 1, 2, ...)
    * @param baseMs - Base delay in milliseconds (default: 1000)
    * @returns Delay in milliseconds with jitter applied
    */
   function calculateBackoffMs(attempt: number, baseMs: number = 1000): number {
     // Exponential: 1s, 2s, 4s, 8s, 16s, 32s
     const exponentialDelay = baseMs * Math.pow(2, attempt);

     // Cap at 32 seconds
     const cappedDelay = Math.min(exponentialDelay, 32000);

     // Full jitter: random value between 0 and delay
     const jitter = Math.random() * cappedDelay;

     return Math.floor(jitter);
   }
   ```

2. **sleep function:**
   ```typescript
   function sleep(ms: number): Promise<void> {
     return new Promise(resolve => setTimeout(resolve, ms));
   }
   ```

3. **buildRetryPrompt function:**
   ```typescript
   /**
    * Build a retry prompt that includes the validation error feedback.
    * Helps the model self-correct on subsequent attempts.
    */
   function buildRetryPrompt(
     originalPrompt: string,
     failedOutput: unknown,
     validationError: string | object
   ): string {
     const errorStr = typeof validationError === 'string'
       ? validationError
       : JSON.stringify(validationError, null, 2);

     return `${originalPrompt}

---

Your previous response did not match the required output schema.

Your output:
\`\`\`json
${JSON.stringify(failedOutput, null, 2)}
\`\`\`

Schema validation error:
${errorStr}

Please provide a corrected response that strictly matches the required schema.`;
   }
   ```
  </action>
  <verify>bun run typecheck</verify>
  <done>calculateBackoffMs, sleep, buildRetryPrompt functions exported from retry.ts</done>
</task>

</tasks>

<verification>
```bash
# Type check passes
bun run typecheck

# Files exist with expected exports
ls src/runtimes/ai/types.ts src/runtimes/ai/errors.ts src/runtimes/ai/retry.ts

# Quick import test
echo "import { AINodeConfig, AIResult, AIErrorCode } from './src/runtimes/ai/types.ts';
import { AIError, SchemaValidationError, isRateLimitError } from './src/runtimes/ai/errors.ts';
import { calculateBackoffMs, sleep, buildRetryPrompt } from './src/runtimes/ai/retry.ts';
console.log('Imports OK');" | bun run -
```
</verification>

<success_criteria>
- [ ] `src/runtimes/ai/types.ts` exports AINodeConfig, AIResult, AIErrorCode
- [ ] `src/runtimes/ai/errors.ts` exports AIError, SchemaValidationError, isRateLimitError
- [ ] `src/runtimes/ai/retry.ts` exports calculateBackoffMs, sleep, buildRetryPrompt
- [ ] `bun run typecheck` passes
- [ ] Error classes use Object.setPrototypeOf pattern
- [ ] calculateBackoffMs implements full jitter capped at 32s
</success_criteria>

<output>
After completion, create `.planning/phases/04-ai-integration/04-01-SUMMARY.md`
</output>
