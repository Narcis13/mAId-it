---
phase: 04-ai-integration
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/runtimes/ai/schema-dsl.ts
autonomous: true

must_haves:
  truths:
    - parseSchemaDSL("{name: string}") returns z.object({name: z.string()})
    - parseSchemaDSL("string[]") returns z.array(z.string())
    - parseSchemaDSL("{user: {name: string}}") handles nested objects
    - Invalid syntax throws descriptive error with the problematic token
    - Primitives string, number, boolean map to z.string(), z.number(), z.boolean()
  artifacts:
    - src/runtimes/ai/schema-dsl.ts
  key_links:
    - parseSchemaDSL returns zod schema that can be used with z.safeParse()
    - Schema can be converted to JSON Schema via z.toJSONSchema() for pi-ai tool definition
---

<objective>
Create a TypeScript-like schema DSL parser that converts inline syntax to Zod schemas.

Purpose: Enable users to declare output schemas inline with familiar TypeScript-like syntax (`{name: string, tags: string[]}`) instead of verbose Zod API calls.

Output: `src/runtimes/ai/schema-dsl.ts` with `parseSchemaDSL(dsl: string): z.ZodType` function.
</objective>

<execution_context>
@/Users/narcisbrindusescu/.claude/looppool/workflows/execute-plan.md
@/Users/narcisbrindusescu/.claude/looppool/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-ai-integration/04-CONTEXT.md
@.planning/phases/04-ai-integration/04-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create schema DSL parser</name>
  <files>src/runtimes/ai/schema-dsl.ts</files>
  <action>
Create `src/runtimes/ai/schema-dsl.ts` with:

1. **Supported syntax:**
   - Primitives: `string`, `number`, `boolean`
   - Arrays: `string[]`, `number[]`, `Type[]`
   - Objects: `{key: Type, key2: Type2}`
   - Nested: `{user: {name: string}, tags: string[]}`

2. **Implementation:**

```typescript
import { z } from 'zod';

/**
 * Schema DSL Parser
 *
 * Parses TypeScript-like schema syntax into Zod schemas.
 *
 * @example
 * parseSchemaDSL("string") // => z.string()
 * parseSchemaDSL("number[]") // => z.array(z.number())
 * parseSchemaDSL("{name: string}") // => z.object({name: z.string()})
 * parseSchemaDSL("{user: {name: string}, tags: string[]}")
 *   // => z.object({user: z.object({name: z.string()}), tags: z.array(z.string())})
 */
export function parseSchemaDSL(dsl: string): z.ZodType {
  const trimmed = dsl.trim();

  // Primitive types
  if (trimmed === 'string') return z.string();
  if (trimmed === 'number') return z.number();
  if (trimmed === 'boolean') return z.boolean();

  // Array types: Type[]
  if (trimmed.endsWith('[]')) {
    const elementType = trimmed.slice(0, -2);
    return z.array(parseSchemaDSL(elementType));
  }

  // Object types: {key: Type, ...}
  if (trimmed.startsWith('{') && trimmed.endsWith('}')) {
    const inner = trimmed.slice(1, -1).trim();
    if (inner === '') {
      return z.object({});
    }

    const shape: Record<string, z.ZodType> = {};
    const pairs = splitByCommaRespectingBraces(inner);

    for (const pair of pairs) {
      const colonIndex = findFirstColonOutsideBraces(pair);
      if (colonIndex === -1) {
        throw new SchemaDSLError(`Invalid schema syntax: missing colon in "${pair}"`);
      }

      const key = pair.slice(0, colonIndex).trim();
      const valueType = pair.slice(colonIndex + 1).trim();

      if (!key) {
        throw new SchemaDSLError(`Invalid schema syntax: empty key in "${pair}"`);
      }
      if (!valueType) {
        throw new SchemaDSLError(`Invalid schema syntax: empty type for key "${key}"`);
      }

      shape[key] = parseSchemaDSL(valueType);
    }

    return z.object(shape);
  }

  throw new SchemaDSLError(`Unknown schema type: "${trimmed}"`);
}
```

3. **Helper functions:**

```typescript
/**
 * Split string by comma, but respect nested braces.
 * "{a: {b: string}, c: number}" should split to ["{a: {b: string}}", "c: number"]
 */
function splitByCommaRespectingBraces(str: string): string[] {
  const pairs: string[] = [];
  let current = '';
  let depth = 0;

  for (const char of str) {
    if (char === '{') depth++;
    if (char === '}') depth--;
    if (char === ',' && depth === 0) {
      if (current.trim()) {
        pairs.push(current.trim());
      }
      current = '';
    } else {
      current += char;
    }
  }

  if (current.trim()) {
    pairs.push(current.trim());
  }

  return pairs;
}

/**
 * Find first colon that isn't inside braces.
 * For "user: {name: string}", should return 4 (the first colon).
 */
function findFirstColonOutsideBraces(str: string): number {
  let depth = 0;
  for (let i = 0; i < str.length; i++) {
    const char = str[i];
    if (char === '{') depth++;
    if (char === '}') depth--;
    if (char === ':' && depth === 0) {
      return i;
    }
  }
  return -1;
}
```

4. **Error class:**

```typescript
/**
 * Error thrown when schema DSL parsing fails.
 */
export class SchemaDSLError extends Error {
  constructor(message: string) {
    super(message);
    this.name = 'SchemaDSLError';
    Object.setPrototypeOf(this, SchemaDSLError.prototype);
  }
}
```
  </action>
  <verify>bun run typecheck</verify>
  <done>parseSchemaDSL and SchemaDSLError exported from schema-dsl.ts</done>
</task>

<task type="auto">
  <name>Task 2: Add schema DSL tests</name>
  <files>src/runtimes/ai/schema-dsl.test.ts</files>
  <action>
Create `src/runtimes/ai/schema-dsl.test.ts` with comprehensive tests:

```typescript
import { test, expect, describe } from 'bun:test';
import { z } from 'zod';
import { parseSchemaDSL, SchemaDSLError } from './schema-dsl.ts';

describe('parseSchemaDSL', () => {
  describe('primitives', () => {
    test('parses string type', () => {
      const schema = parseSchemaDSL('string');
      expect(schema.safeParse('hello').success).toBe(true);
      expect(schema.safeParse(123).success).toBe(false);
    });

    test('parses number type', () => {
      const schema = parseSchemaDSL('number');
      expect(schema.safeParse(42).success).toBe(true);
      expect(schema.safeParse('42').success).toBe(false);
    });

    test('parses boolean type', () => {
      const schema = parseSchemaDSL('boolean');
      expect(schema.safeParse(true).success).toBe(true);
      expect(schema.safeParse('true').success).toBe(false);
    });
  });

  describe('arrays', () => {
    test('parses string array', () => {
      const schema = parseSchemaDSL('string[]');
      expect(schema.safeParse(['a', 'b']).success).toBe(true);
      expect(schema.safeParse([1, 2]).success).toBe(false);
    });

    test('parses number array', () => {
      const schema = parseSchemaDSL('number[]');
      expect(schema.safeParse([1, 2, 3]).success).toBe(true);
    });
  });

  describe('objects', () => {
    test('parses simple object', () => {
      const schema = parseSchemaDSL('{name: string}');
      expect(schema.safeParse({ name: 'Alice' }).success).toBe(true);
      expect(schema.safeParse({ name: 123 }).success).toBe(false);
    });

    test('parses multi-field object', () => {
      const schema = parseSchemaDSL('{name: string, age: number}');
      expect(schema.safeParse({ name: 'Alice', age: 30 }).success).toBe(true);
    });

    test('parses object with array field', () => {
      const schema = parseSchemaDSL('{name: string, tags: string[]}');
      expect(schema.safeParse({ name: 'Alice', tags: ['a', 'b'] }).success).toBe(true);
    });

    test('parses nested object', () => {
      const schema = parseSchemaDSL('{user: {name: string, age: number}}');
      expect(schema.safeParse({ user: { name: 'Alice', age: 30 } }).success).toBe(true);
    });

    test('parses complex nested structure', () => {
      const schema = parseSchemaDSL('{users: {name: string}[], count: number}');
      expect(schema.safeParse({
        users: [{ name: 'Alice' }, { name: 'Bob' }],
        count: 2
      }).success).toBe(true);
    });

    test('parses empty object', () => {
      const schema = parseSchemaDSL('{}');
      expect(schema.safeParse({}).success).toBe(true);
    });
  });

  describe('error handling', () => {
    test('throws on unknown type', () => {
      expect(() => parseSchemaDSL('unknown')).toThrow(SchemaDSLError);
    });

    test('throws on missing colon', () => {
      expect(() => parseSchemaDSL('{name string}')).toThrow(SchemaDSLError);
    });

    test('throws on empty key', () => {
      expect(() => parseSchemaDSL('{: string}')).toThrow(SchemaDSLError);
    });

    test('throws on empty value', () => {
      expect(() => parseSchemaDSL('{name: }')).toThrow(SchemaDSLError);
    });
  });

  describe('whitespace handling', () => {
    test('handles extra whitespace', () => {
      const schema = parseSchemaDSL('  { name : string , age : number }  ');
      expect(schema.safeParse({ name: 'Alice', age: 30 }).success).toBe(true);
    });
  });

  describe('JSON Schema export', () => {
    test('can convert to JSON Schema for pi-ai', () => {
      const schema = parseSchemaDSL('{name: string, count: number}');
      // Zod v4 has native toJSONSchema
      const jsonSchema = z.toJSONSchema(schema);
      expect(jsonSchema.type).toBe('object');
      expect(jsonSchema.properties).toHaveProperty('name');
      expect(jsonSchema.properties).toHaveProperty('count');
    });
  });
});
```
  </action>
  <verify>bun test src/runtimes/ai/schema-dsl.test.ts</verify>
  <done>All schema DSL tests pass</done>
</task>

</tasks>

<verification>
```bash
# Type check passes
bun run typecheck

# Tests pass
bun test src/runtimes/ai/schema-dsl.test.ts

# Quick validation of complex schema
echo "import { parseSchemaDSL } from './src/runtimes/ai/schema-dsl.ts';
import { z } from 'zod';
const schema = parseSchemaDSL('{user: {name: string, tags: string[]}, count: number}');
const result = schema.safeParse({user: {name: 'test', tags: ['a']}, count: 1});
console.log('Parse result:', result.success);
const jsonSchema = z.toJSONSchema(schema);
console.log('JSON Schema keys:', Object.keys(jsonSchema.properties || {}));" | bun run -
```
</verification>

<success_criteria>
- [ ] `parseSchemaDSL("string")` returns z.string()
- [ ] `parseSchemaDSL("string[]")` returns z.array(z.string())
- [ ] `parseSchemaDSL("{name: string}")` returns z.object({name: z.string()})
- [ ] Nested objects work: `{user: {name: string}}`
- [ ] Complex structures work: `{users: {name: string}[], count: number}`
- [ ] Invalid syntax throws SchemaDSLError with helpful message
- [ ] Output schema can be converted to JSON Schema via z.toJSONSchema()
- [ ] All tests pass with `bun test`
</success_criteria>

<output>
After completion, create `.planning/phases/04-ai-integration/04-02-SUMMARY.md`
</output>
