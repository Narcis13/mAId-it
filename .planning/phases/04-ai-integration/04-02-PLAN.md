---
phase: 04-ai-integration
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/runtimes/ai/schema-parser.ts
autonomous: true

must_haves:
  truths:
    - "parseSchemaString converts TypeScript-like DSL to zod schema"
    - "Supports primitives (string, number, boolean), arrays (T[]), and nested objects"
    - "toOpenRouterSchema converts zod schema to OpenRouter json_schema format"
    - "Parser throws clear errors for unsupported syntax"
  artifacts:
    - src/runtimes/ai/schema-parser.ts
  key_links:
    - "parseSchemaString returns z.ZodSchema for validation"
    - "toOpenRouterSchema uses z.toJSONSchema() for conversion"
    - "Nested objects like {meta: {count: number}} parse correctly"
---

<objective>
Create schema DSL parser that converts TypeScript-like inline schema syntax to zod schemas.

Purpose: Enable users to declare output schemas inline using familiar TypeScript object literal syntax (e.g., `output-schema="{name: string, tags: string[]}"`) instead of verbose zod imports.

Output: Schema parser utility in src/runtimes/ai/schema-parser.ts with parsing and JSON Schema conversion.
</objective>

<execution_context>
@/Users/narcisbrindusescu/.claude/looppool/workflows/execute-plan.md
@/Users/narcisbrindusescu/.claude/looppool/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-ai-integration/04-CONTEXT.md
@.planning/phases/04-ai-integration/04-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create schema DSL parser</name>
  <files>src/runtimes/ai/schema-parser.ts</files>
  <action>
Create `src/runtimes/ai/schema-parser.ts` implementing a recursive descent parser for TypeScript-like schema DSL:

**Supported syntax:**
- Primitives: `string`, `number`, `boolean`
- Arrays: `string[]`, `number[]`, `{name: string}[]`
- Objects: `{name: string, age: number}`
- Nested objects: `{user: {name: string}, tags: string[]}`

**NOT supported (document in JSDoc):**
- Optional properties (`name?: string`)
- Union types (`string | number`)
- Generics (`Array<string>`)
- Literal types (`"active" | "inactive"`)

**Implementation:**

```typescript
import { z } from 'zod';

/**
 * Parse TypeScript-like schema DSL string into a zod schema.
 *
 * Supported syntax:
 * - Primitives: string, number, boolean
 * - Arrays: T[] (e.g., string[], number[], {name: string}[])
 * - Objects: {key: type, key2: type2}
 * - Nested: {user: {name: string}, items: {id: number}[]}
 *
 * @example
 * parseSchemaString('string') // z.string()
 * parseSchemaString('{name: string, tags: string[]}') // z.object({name: z.string(), tags: z.array(z.string())})
 *
 * @throws Error if syntax is unsupported
 */
export function parseSchemaString(dsl: string): z.ZodSchema {
  const trimmed = dsl.trim();

  // Primitives
  if (trimmed === 'string') return z.string();
  if (trimmed === 'number') return z.number();
  if (trimmed === 'boolean') return z.boolean();

  // Arrays: T[] - need to find matching [] at the end
  // Handle complex cases like {name: string}[]
  if (trimmed.endsWith('[]')) {
    const elementType = findArrayElementType(trimmed);
    return z.array(parseSchemaString(elementType));
  }

  // Objects: {key: type, ...}
  if (trimmed.startsWith('{') && trimmed.endsWith('}')) {
    const inner = trimmed.slice(1, -1).trim();
    if (inner === '') return z.object({});

    const properties = parseObjectProperties(inner);
    const shape: Record<string, z.ZodSchema> = {};
    for (const [key, value] of properties) {
      shape[key] = parseSchemaString(value);
    }
    return z.object(shape);
  }

  throw new Error(`Unsupported schema syntax: "${trimmed}". Supported: string, number, boolean, T[], {key: type}`);
}

/**
 * Find the element type for an array, handling nested objects.
 * For "{name: string}[]", returns "{name: string}"
 * For "string[]", returns "string"
 */
function findArrayElementType(dsl: string): string {
  // Remove trailing []
  const withoutBrackets = dsl.slice(0, -2);

  // If it's a simple type or already balanced braces, return it
  if (!withoutBrackets.includes('{')) {
    return withoutBrackets;
  }

  // For object arrays, the element type is everything before []
  return withoutBrackets;
}

/**
 * Parse object properties from the inner content of {...}.
 * Handles nested objects by tracking brace depth.
 *
 * @example
 * "name: string, age: number" -> [["name", "string"], ["age", "number"]]
 * "user: {name: string}, tags: string[]" -> [["user", "{name: string}"], ["tags", "string[]"]]
 */
function parseObjectProperties(inner: string): [string, string][] {
  const properties: [string, string][] = [];
  let current = '';
  let braceDepth = 0;
  let inKey = true;
  let key = '';

  for (let i = 0; i < inner.length; i++) {
    const char = inner[i];

    if (char === '{') {
      braceDepth++;
      current += char;
    } else if (char === '}') {
      braceDepth--;
      current += char;
    } else if (char === ':' && braceDepth === 0 && inKey) {
      // Found key-value separator at top level
      key = current.trim();
      current = '';
      inKey = false;
    } else if (char === ',' && braceDepth === 0) {
      // Found property separator at top level
      properties.push([key, current.trim()]);
      current = '';
      key = '';
      inKey = true;
    } else {
      current += char;
    }
  }

  // Don't forget the last property
  if (key && current.trim()) {
    properties.push([key, current.trim()]);
  }

  return properties;
}

/**
 * Convert a zod schema to OpenRouter's json_schema response format.
 *
 * @example
 * const schema = parseSchemaString('{name: string}');
 * const orSchema = toOpenRouterSchema(schema, 'extraction');
 * // { type: 'json_schema', json_schema: { name: 'extraction', strict: true, schema: {...} } }
 */
export function toOpenRouterSchema(zodSchema: z.ZodSchema, name: string): {
  type: 'json_schema';
  json_schema: {
    name: string;
    strict: boolean;
    schema: object;
  };
} {
  return {
    type: 'json_schema',
    json_schema: {
      name,
      strict: true,
      schema: z.toJSONSchema(zodSchema),
    },
  };
}

/**
 * Format validation errors for AI model feedback.
 * Makes errors understandable so the model can self-correct.
 */
export function formatValidationError(
  error: z.ZodError,
  originalResponse: string,
  expectedSchema: string
): string {
  const issues = error.issues.map(issue => {
    const path = issue.path.length > 0 ? issue.path.join('.') : 'root';
    return `- ${path}: ${issue.message}`;
  }).join('\n');

  return `Validation failed. Your response did not match the expected schema.

Expected schema: ${expectedSchema}

Issues:
${issues}

Your response was:
${originalResponse.slice(0, 500)}${originalResponse.length > 500 ? '...' : ''}

Please try again with the correct structure.`;
}
```
  </action>
  <verify>bun --eval "import { parseSchemaString, toOpenRouterSchema } from './src/runtimes/ai/schema-parser.ts'; const schema = parseSchemaString('{name: string, tags: string[]}'); console.log('Schema parsed OK'); const or = toOpenRouterSchema(schema, 'test'); console.log('OpenRouter format:', JSON.stringify(or.json_schema.schema, null, 2))"</verify>
  <done>Schema parser exists with parseSchemaString, toOpenRouterSchema, formatValidationError functions</done>
</task>

<task type="auto">
  <name>Task 2: Add comprehensive test cases</name>
  <files>src/runtimes/ai/schema-parser.test.ts</files>
  <action>
Create `src/runtimes/ai/schema-parser.test.ts` with tests covering:

```typescript
import { test, expect, describe } from 'bun:test';
import { z } from 'zod';
import { parseSchemaString, toOpenRouterSchema, formatValidationError } from './schema-parser.ts';

describe('parseSchemaString', () => {
  describe('primitives', () => {
    test('parses string', () => {
      const schema = parseSchemaString('string');
      expect(schema.safeParse('hello').success).toBe(true);
      expect(schema.safeParse(123).success).toBe(false);
    });

    test('parses number', () => {
      const schema = parseSchemaString('number');
      expect(schema.safeParse(42).success).toBe(true);
      expect(schema.safeParse('42').success).toBe(false);
    });

    test('parses boolean', () => {
      const schema = parseSchemaString('boolean');
      expect(schema.safeParse(true).success).toBe(true);
      expect(schema.safeParse('true').success).toBe(false);
    });
  });

  describe('arrays', () => {
    test('parses string[]', () => {
      const schema = parseSchemaString('string[]');
      expect(schema.safeParse(['a', 'b']).success).toBe(true);
      expect(schema.safeParse([1, 2]).success).toBe(false);
    });

    test('parses number[]', () => {
      const schema = parseSchemaString('number[]');
      expect(schema.safeParse([1, 2, 3]).success).toBe(true);
    });

    test('parses object array {name: string}[]', () => {
      const schema = parseSchemaString('{name: string}[]');
      expect(schema.safeParse([{name: 'Alice'}, {name: 'Bob'}]).success).toBe(true);
      expect(schema.safeParse([{name: 123}]).success).toBe(false);
    });
  });

  describe('objects', () => {
    test('parses simple object', () => {
      const schema = parseSchemaString('{name: string, age: number}');
      expect(schema.safeParse({name: 'Alice', age: 30}).success).toBe(true);
      expect(schema.safeParse({name: 'Alice'}).success).toBe(false);
    });

    test('parses empty object', () => {
      const schema = parseSchemaString('{}');
      expect(schema.safeParse({}).success).toBe(true);
    });

    test('parses nested object', () => {
      const schema = parseSchemaString('{user: {name: string, age: number}, active: boolean}');
      expect(schema.safeParse({user: {name: 'Alice', age: 30}, active: true}).success).toBe(true);
    });

    test('parses object with array property', () => {
      const schema = parseSchemaString('{name: string, tags: string[]}');
      expect(schema.safeParse({name: 'Item', tags: ['a', 'b']}).success).toBe(true);
    });

    test('parses complex nested structure', () => {
      const schema = parseSchemaString('{users: {name: string, roles: string[]}[], count: number}');
      expect(schema.safeParse({
        users: [{name: 'Alice', roles: ['admin']}],
        count: 1
      }).success).toBe(true);
    });
  });

  describe('error handling', () => {
    test('throws on unsupported type', () => {
      expect(() => parseSchemaString('Date')).toThrow(/Unsupported schema syntax/);
    });

    test('throws on union types', () => {
      expect(() => parseSchemaString('string | number')).toThrow(/Unsupported/);
    });
  });
});

describe('toOpenRouterSchema', () => {
  test('generates correct format', () => {
    const schema = parseSchemaString('{name: string}');
    const result = toOpenRouterSchema(schema, 'extraction');

    expect(result.type).toBe('json_schema');
    expect(result.json_schema.name).toBe('extraction');
    expect(result.json_schema.strict).toBe(true);
    expect(result.json_schema.schema).toHaveProperty('type', 'object');
    expect(result.json_schema.schema).toHaveProperty('properties');
  });
});

describe('formatValidationError', () => {
  test('formats error for AI feedback', () => {
    const schema = z.object({ name: z.string() });
    const result = schema.safeParse({ name: 123 });

    if (!result.success) {
      const formatted = formatValidationError(
        result.error,
        '{"name": 123}',
        '{name: string}'
      );

      expect(formatted).toContain('Validation failed');
      expect(formatted).toContain('{name: string}');
      expect(formatted).toContain('name');
    }
  });
});
```
  </action>
  <verify>bun test src/runtimes/ai/schema-parser.test.ts</verify>
  <done>All schema parser tests pass, covering primitives, arrays, objects, nested structures, and error cases</done>
</task>

</tasks>

<verification>
```bash
# Run all schema parser tests
bun test src/runtimes/ai/schema-parser.test.ts

# Verify complex schema parsing
bun --eval "
import { parseSchemaString, toOpenRouterSchema } from './src/runtimes/ai/schema-parser.ts';

// Test the exact schema pattern from CONTEXT.md
const schema = parseSchemaString('{name: string, tags: string[]}');
const valid = schema.safeParse({name: 'Test', tags: ['a', 'b']});
console.log('Valid data passes:', valid.success);

const invalid = schema.safeParse({name: 123, tags: 'not-array'});
console.log('Invalid data fails:', !invalid.success);

// Test OpenRouter format generation
const orSchema = toOpenRouterSchema(schema, 'extraction');
console.log('OpenRouter schema generated:', orSchema.json_schema.name === 'extraction');
"
```
</verification>

<success_criteria>
- [ ] parseSchemaString('string') returns z.string()
- [ ] parseSchemaString('number') returns z.number()
- [ ] parseSchemaString('boolean') returns z.boolean()
- [ ] parseSchemaString('string[]') returns z.array(z.string())
- [ ] parseSchemaString('{name: string}') returns z.object({name: z.string()})
- [ ] parseSchemaString('{name: string, tags: string[]}') handles mixed object with array
- [ ] parseSchemaString('{user: {name: string}}') handles nested objects
- [ ] toOpenRouterSchema generates correct format with type: 'json_schema'
- [ ] formatValidationError produces AI-friendly error message
- [ ] All test cases pass
</success_criteria>

<output>
After completion, create `.planning/phases/04-ai-integration/04-02-SUMMARY.md`
</output>
