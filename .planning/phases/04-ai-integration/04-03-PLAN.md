---
phase: 04-ai-integration
plan: 03
type: execute
wave: 2
depends_on: ["04-01", "04-02"]
files_modified:
  - src/runtimes/ai/openrouter.ts
  - src/runtimes/ai/runtime.ts
  - src/runtimes/ai/index.ts
  - src/runtimes/index.ts
  - src/runtimes/types.ts
autonomous: true

must_haves:
  truths:
    - "AI runtime calls OpenRouter API with model selection (AI-01)"
    - "AI runtime supports system and user prompts with template expressions (AI-02, AI-03)"
    - "AI output is validated against zod schema from DSL (AI-04)"
    - "AI runtime retries on schema validation failure with error feedback (AI-05)"
    - "AI runtime handles 429 rate limits with exponential backoff (AI-06)"
    - "AI runtime respects maxTokens configuration (AI-07)"
  artifacts:
    - src/runtimes/ai/openrouter.ts
    - src/runtimes/ai/runtime.ts
    - src/runtimes/ai/index.ts
  key_links:
    - "AiTransformRuntime implements NodeRuntime<AiConfig, unknown, unknown>"
    - "Runtime registered as 'ai:transform' in registry"
    - "OpenRouter client handles structured output via json_schema response format"
---

<objective>
Create the AI transform runtime that calls OpenRouter API with structured output validation.

Purpose: Enable AI-powered workflow nodes that call models (Claude, GPT, etc.) with prompt templating, validate responses against schemas, and retry intelligently on failures.

Output: Complete AI runtime in src/runtimes/ai/ with OpenRouter client, runtime implementation, and module registration.
</objective>

<execution_context>
@/Users/narcisbrindusescu/.claude/looppool/workflows/execute-plan.md
@/Users/narcisbrindusescu/.claude/looppool/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-ai-integration/04-CONTEXT.md
@.planning/phases/04-ai-integration/04-RESEARCH.md

# Prior plan outputs needed
@.planning/phases/04-ai-integration/04-01-SUMMARY.md
@.planning/phases/04-ai-integration/04-02-SUMMARY.md

# Existing runtime patterns
@src/runtimes/types.ts
@src/runtimes/http/source.ts
@src/runtimes/http/index.ts
@src/runtimes/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create OpenRouter API client</name>
  <files>src/runtimes/ai/openrouter.ts</files>
  <action>
Create `src/runtimes/ai/openrouter.ts` as a thin wrapper for OpenRouter chat completions API:

```typescript
/**
 * OpenRouter API Client for FlowScript
 *
 * Provides low-level API access to OpenRouter's chat completions endpoint.
 * Handles authentication, request formatting, and response parsing.
 */

import type { OpenRouterRequest, OpenRouterResponse } from './types.ts';
import { AiError } from './errors.ts';
import { withRetry, parseRetryAfter } from './retry.ts';

const OPENROUTER_API_URL = 'https://openrouter.ai/api/v1/chat/completions';

/**
 * Call OpenRouter chat completions API.
 *
 * @param request - The chat completion request
 * @param apiKey - OpenRouter API key
 * @param timeout - Request timeout in milliseconds (default: 60000)
 * @returns The API response
 * @throws AiError on API failures
 */
export async function callOpenRouter(
  request: OpenRouterRequest,
  apiKey: string,
  timeout: number = 60000
): Promise<OpenRouterResponse> {
  const response = await fetch(OPENROUTER_API_URL, {
    method: 'POST',
    headers: {
      'Authorization': `Bearer ${apiKey}`,
      'Content-Type': 'application/json',
      'HTTP-Referer': 'https://flowscript.dev',  // Required by OpenRouter
      'X-Title': 'FlowScript Workflow Engine',   // Helpful for tracking
    },
    body: JSON.stringify(request),
    signal: AbortSignal.timeout(timeout),
  });

  if (!response.ok) {
    const body = await response.text().catch(() => '');
    throw new AiError(
      `OpenRouter API error: ${response.status} ${response.statusText}`,
      response.status,
      body
    );
  }

  const data = await response.json() as OpenRouterResponse;
  return data;
}

/**
 * Call OpenRouter with automatic retry on rate limits.
 *
 * @param request - The chat completion request
 * @param apiKey - OpenRouter API key
 * @param timeout - Request timeout in milliseconds
 * @param maxRetries - Maximum retry attempts for rate limits
 * @param onRetry - Optional callback for retry events
 * @returns The API response
 */
export async function callOpenRouterWithRetry(
  request: OpenRouterRequest,
  apiKey: string,
  timeout: number = 60000,
  maxRetries: number = 3,
  onRetry?: (attempt: number, delay: number) => void
): Promise<OpenRouterResponse> {
  return withRetry(
    () => callOpenRouter(request, apiKey, timeout),
    (error) => error instanceof AiError && error.isRateLimited,
    { maxAttempts: maxRetries, baseDelay: 1000, maxDelay: 32000 },
    (attempt, _error, delay) => onRetry?.(attempt, delay)
  );
}

/**
 * Extract text content from OpenRouter response.
 * Handles markdown code fences that models sometimes return.
 */
export function extractContent(response: OpenRouterResponse): string {
  const content = response.choices[0]?.message?.content ?? '';

  // Strip markdown JSON code fences if present
  const jsonMatch = content.match(/```(?:json)?\s*([\s\S]*?)```/);
  if (jsonMatch) {
    return jsonMatch[1].trim();
  }

  return content.trim();
}
```
  </action>
  <verify>bun --eval "import { callOpenRouter, extractContent } from './src/runtimes/ai/openrouter.ts'; console.log('OpenRouter client compiles OK')"</verify>
  <done>OpenRouter client exists with callOpenRouter, callOpenRouterWithRetry, extractContent functions</done>
</task>

<task type="auto">
  <name>Task 2: Create AI transform runtime</name>
  <files>src/runtimes/ai/runtime.ts</files>
  <action>
Create `src/runtimes/ai/runtime.ts` implementing the full AI runtime:

```typescript
/**
 * AI Transform Runtime for FlowScript
 *
 * Calls AI models via OpenRouter with:
 * - System and user prompts with template expression support
 * - Structured output validation via zod schemas
 * - Automatic retry on validation failures
 * - Rate limit handling with exponential backoff
 */

import { z } from 'zod';
import type { NodeRuntime, ExecutionParams, AiConfig } from '../types.ts';
import type { ExecutionState } from '../../execution/types.ts';
import { evaluateTemplateInContext } from '../../execution/index.ts';
import { AiError, SchemaValidationError } from './errors.ts';
import { callOpenRouterWithRetry, extractContent } from './openrouter.ts';
import { parseSchemaString, toOpenRouterSchema, formatValidationError } from './schema-parser.ts';
import type { OpenRouterRequest } from './types.ts';

// ============================================================================
// Constants
// ============================================================================

const DEFAULT_MAX_TOKENS = 4096;
const DEFAULT_TIMEOUT = 60000;  // 60 seconds
const DEFAULT_MAX_RETRIES = 3;
const VALIDATION_RETRY_DELAYS = [0, 1000, 2000];  // Immediate, 1s, 2s for validation retries

// ============================================================================
// Helper Functions
// ============================================================================

/**
 * Resolve template expressions in a prompt string.
 */
function resolvePrompt(template: string, state: ExecutionState): string {
  return evaluateTemplateInContext(template, state);
}

/**
 * Get API key from secrets in execution state.
 */
function getApiKey(state: ExecutionState): string {
  const key = state.secrets?.OPENROUTER_API_KEY;
  if (!key) {
    throw new AiError('Missing OPENROUTER_API_KEY in secrets');
  }
  return key;
}

/**
 * Parse and validate JSON response.
 */
function parseJsonResponse(content: string): unknown {
  try {
    return JSON.parse(content);
  } catch {
    throw new SchemaValidationError(
      'AI response is not valid JSON',
      content,
      [{ path: 'root', expected: 'valid JSON', received: 'invalid JSON', message: 'Failed to parse JSON' }]
    );
  }
}

// ============================================================================
// AI Transform Runtime
// ============================================================================

/**
 * AI Transform Runtime implementation.
 *
 * Calls AI models via OpenRouter and validates output against schemas.
 *
 * @example
 * ```xml
 * <ai:transform id="extract-info"
 *   model="anthropic/claude-3.5-sonnet"
 *   input="{{previous.output}}"
 *   output-schema="{name: string, tags: string[]}"
 *   max-tokens="1024"
 * >
 *   <system>You are a helpful assistant. Return JSON only.</system>
 *   <user>Extract the name and tags from: {{$input}}</user>
 * </ai:transform>
 * ```
 */
class AiTransformRuntime implements NodeRuntime<AiConfig, unknown, unknown> {
  readonly type = 'ai:transform';

  async execute(params: ExecutionParams<AiConfig, unknown>): Promise<unknown> {
    const { config, state, input } = params;

    // Get configuration with defaults
    const maxTokens = config.maxTokens ?? DEFAULT_MAX_TOKENS;
    const timeout = config.timeout ?? DEFAULT_TIMEOUT;
    const maxRetries = config.maxRetries ?? DEFAULT_MAX_RETRIES;

    // Get API key from secrets
    const apiKey = getApiKey(state);

    // Create state with input available
    const stateWithInput: ExecutionState = {
      ...state,
      context: {
        ...state.context,
        $input: input,
      },
    };

    // Resolve template expressions in prompts
    const systemPrompt = config.systemPrompt
      ? resolvePrompt(config.systemPrompt, stateWithInput)
      : undefined;
    const userPrompt = resolvePrompt(config.userPrompt, stateWithInput);

    // Parse output schema if provided
    let zodSchema: z.ZodSchema | undefined;
    let responseFormat: OpenRouterRequest['response_format'];

    if (config.outputSchema) {
      zodSchema = parseSchemaString(config.outputSchema);
      responseFormat = toOpenRouterSchema(zodSchema, 'output');
    }

    // Build messages
    const messages: OpenRouterRequest['messages'] = [];

    if (systemPrompt) {
      // Add JSON instruction if we have a schema
      const systemContent = zodSchema
        ? `${systemPrompt}\n\nIMPORTANT: You must respond with valid JSON only. No explanations or markdown.`
        : systemPrompt;
      messages.push({ role: 'system', content: systemContent });
    } else if (zodSchema) {
      // Add default system prompt for structured output
      messages.push({
        role: 'system',
        content: 'You are a helpful assistant. Respond with valid JSON only. No explanations or markdown.'
      });
    }

    messages.push({ role: 'user', content: userPrompt });

    // Build request
    const request: OpenRouterRequest = {
      model: config.model,
      messages,
      max_tokens: maxTokens,
    };

    if (responseFormat) {
      request.response_format = responseFormat;
    }

    // Execute with validation retry loop
    let lastValidationError: SchemaValidationError | undefined;

    for (let attempt = 0; attempt < maxRetries; attempt++) {
      // If this is a retry due to validation failure, add error feedback
      if (lastValidationError && attempt > 0) {
        const feedbackMessage = formatValidationError(
          // Create a ZodError-like structure for formatting
          { issues: lastValidationError.issues.map(i => ({ path: i.path.split('.'), message: i.message })) } as z.ZodError,
          lastValidationError.response,
          config.outputSchema || ''
        );

        // Add feedback as a new user message
        request.messages = [
          ...messages,
          { role: 'assistant', content: lastValidationError.response },
          { role: 'user', content: feedbackMessage },
        ];

        // Wait before retry (shorter delays for validation)
        if (attempt > 0) {
          const delay = VALIDATION_RETRY_DELAYS[Math.min(attempt, VALIDATION_RETRY_DELAYS.length - 1)];
          await new Promise(resolve => setTimeout(resolve, delay));
        }
      }

      // Call API (this handles rate limit retries internally)
      const response = await callOpenRouterWithRetry(
        attempt === 0 ? request : { ...request },
        apiKey,
        timeout,
        maxRetries
      );

      // Extract content
      const content = extractContent(response);

      // If no schema, return raw content
      if (!zodSchema) {
        // Try to parse as JSON if it looks like JSON
        if (content.startsWith('{') || content.startsWith('[')) {
          try {
            return JSON.parse(content);
          } catch {
            return content;
          }
        }
        return content;
      }

      // Parse and validate JSON
      let parsed: unknown;
      try {
        parsed = parseJsonResponse(content);
      } catch (error) {
        if (error instanceof SchemaValidationError) {
          lastValidationError = error;
          continue;  // Retry
        }
        throw error;
      }

      // Validate against schema
      const result = zodSchema.safeParse(parsed);

      if (result.success) {
        return result.data;
      }

      // Validation failed - prepare for retry
      lastValidationError = new SchemaValidationError(
        'AI output does not match schema',
        content,
        result.error.issues.map(issue => ({
          path: issue.path.join('.'),
          expected: String((issue as any).expected ?? 'valid'),
          received: String((issue as any).received ?? 'invalid'),
          message: issue.message,
        }))
      );
    }

    // All retries exhausted
    throw lastValidationError || new AiError('AI request failed after all retries');
  }
}

/**
 * AI transform runtime instance.
 */
export const aiTransformRuntime = new AiTransformRuntime();
```
  </action>
  <verify>bun --eval "import { aiTransformRuntime } from './src/runtimes/ai/runtime.ts'; console.log('AI runtime compiles OK, type:', aiTransformRuntime.type)"</verify>
  <done>AI runtime exists implementing NodeRuntime with template resolution, schema validation, and retry logic</done>
</task>

<task type="auto">
  <name>Task 3: Create module exports and register runtime</name>
  <files>src/runtimes/ai/index.ts, src/runtimes/index.ts, src/runtimes/types.ts</files>
  <action>
1. **Create `src/runtimes/ai/index.ts`** following http/file pattern:

```typescript
/**
 * AI Runtime Module for FlowScript
 *
 * Provides AI transform runtime for calling models via OpenRouter
 * with structured output validation.
 *
 * @example
 * ```ts
 * // Importing this module auto-registers AI runtime
 * import './ai';
 *
 * // Or import specific exports
 * import { aiTransformRuntime } from './ai';
 * ```
 */

import { aiTransformRuntime } from './runtime.ts';
import { runtimeRegistry } from '../registry.ts';

// ============================================================================
// Auto-Registration
// ============================================================================

// Register AI runtime when module is imported
runtimeRegistry.register(aiTransformRuntime);

// ============================================================================
// Exports
// ============================================================================

export { aiTransformRuntime } from './runtime.ts';
export { parseSchemaString, toOpenRouterSchema, formatValidationError } from './schema-parser.ts';
export { callOpenRouter, callOpenRouterWithRetry, extractContent } from './openrouter.ts';
export { AiError, SchemaValidationError } from './errors.ts';
export { withRetry, calculateJitteredDelay, parseRetryAfter, DEFAULT_RETRY_CONFIG } from './retry.ts';
export type { AiConfig, OpenRouterRequest, OpenRouterResponse, AiResult } from './types.ts';
export type { AiErrorCode, RetryConfig } from './errors.ts';
```

2. **Update `src/runtimes/index.ts`** to include AI runtime:

Add these lines following the existing pattern:
```typescript
// After existing file import
import './ai/index.ts';

// In re-exports section
export { aiTransformRuntime, parseSchemaString, toOpenRouterSchema } from './ai/index.ts';
export { AiError, SchemaValidationError } from './ai/index.ts';
export type { AiConfig, OpenRouterRequest, OpenRouterResponse, AiResult } from './ai/index.ts';
```

3. **Update `src/runtimes/types.ts`** to add AiConfig:

Add to the exports (at end of file):
```typescript
// ============================================================================
// AI Configuration Types
// ============================================================================

/**
 * Configuration for AI transform nodes.
 */
export interface AiConfig {
  /** OpenRouter model ID (e.g., "anthropic/claude-3.5-sonnet") */
  model: string;
  /** System prompt template (supports {{expressions}}) */
  systemPrompt?: string;
  /** User prompt template (supports {{expressions}}) */
  userPrompt: string;
  /** Output schema in TypeScript-like DSL (e.g., "{name: string, tags: string[]}") */
  outputSchema?: string;
  /** Maximum output tokens (default: 4096) */
  maxTokens?: number;
  /** Request timeout in milliseconds (default: 60000) */
  timeout?: number;
  /** Maximum retry attempts (default: 3) */
  maxRetries?: number;
}
```
  </action>
  <verify>bun --eval "import { runtimeRegistry, aiTransformRuntime, AiError } from './src/runtimes/index.ts'; console.log('AI runtime registered:', runtimeRegistry.has('ai:transform')); console.log('All runtimes:', runtimeRegistry.list())"</verify>
  <done>AI runtime module created, registered, and exported from main runtimes index</done>
</task>

</tasks>

<verification>
```bash
# Verify AI runtime is registered
bun --eval "
import { runtimeRegistry } from './src/runtimes/index.ts';
const types = runtimeRegistry.list();
console.log('Registered runtimes:', types);
console.log('AI transform registered:', types.includes('ai:transform'));
"

# Verify all exports work
bun --eval "
import {
  aiTransformRuntime,
  parseSchemaString,
  toOpenRouterSchema,
  AiError,
  SchemaValidationError
} from './src/runtimes/index.ts';
console.log('All exports available');
console.log('Runtime type:', aiTransformRuntime.type);
"

# Verify type imports
bun --eval "
import type { AiConfig } from './src/runtimes/types.ts';
const config: AiConfig = {
  model: 'anthropic/claude-3.5-sonnet',
  userPrompt: 'Hello',
};
console.log('AiConfig type works');
"

# Run schema parser tests (created in Plan 02)
bun test src/runtimes/ai/schema-parser.test.ts
```
</verification>

<success_criteria>
- [ ] OpenRouter client calls API with correct headers and auth (AI-01)
- [ ] Runtime resolves template expressions in system/user prompts (AI-02, AI-03)
- [ ] Runtime parses outputSchema DSL and validates response (AI-04)
- [ ] Runtime retries with error feedback on validation failure (AI-05)
- [ ] Rate limits (429) handled with exponential backoff (AI-06)
- [ ] maxTokens configuration is respected (AI-07)
- [ ] Runtime registered as 'ai:transform' in registry
- [ ] All exports available from src/runtimes/index.ts
- [ ] AiConfig type available from src/runtimes/types.ts
</success_criteria>

<output>
After completion, create `.planning/phases/04-ai-integration/04-03-SUMMARY.md`
</output>
