---
phase: 04-ai-integration
plan: 04
type: execute
wave: 2
depends_on: ["04-02"]
files_modified:
  - src/types/errors.ts
  - src/validator/types.ts
  - src/validator/index.ts
autonomous: true

must_haves:
  truths:
    - validateTypeCompatibility checks AI node output schema against downstream node input expectations
    - Validator warns when AI node with output-schema feeds node expecting different structure
    - Type compatibility validation runs as Pass 4 after reference validation
    - Validation produces warnings (not errors) since runtime types are dynamic
    - AI nodes without output-schema are skipped (no static type to check)
  artifacts:
    - src/validator/types.ts
  key_links:
    - validateTypeCompatibility integrated into main validate() function
    - parseSchemaDSL used to parse AI node output-schema for comparison
    - Validation uses input references to find downstream consumers
---

<objective>
Add type compatibility validation for AI nodes to warn when output schemas may not match downstream expectations.

Purpose: Provide early feedback when an AI node's declared output-schema might not match what downstream nodes expect, helping users catch schema mismatches before runtime.

Output: New validation pass in `src/validator/types.ts` that checks AI node output schema compatibility.
</objective>

<execution_context>
@/Users/narcisbrindusescu/.claude/looppool/workflows/execute-plan.md
@/Users/narcisbrindusescu/.claude/looppool/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-ai-integration/04-CONTEXT.md
@.planning/phases/04-ai-integration/04-02-SUMMARY.md

<!-- Existing validator structure -->
@src/validator/index.ts
@src/validator/references.ts
@src/validator/structural.ts

<!-- AST types for node structure -->
@src/types/ast.ts

<!-- Error types - need to add new error codes -->
@src/types/errors.ts

<!-- Schema DSL parser -->
@src/runtimes/ai/schema-dsl.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add error codes and create type compatibility validator</name>
  <files>src/types/errors.ts, src/validator/types.ts</files>
  <action>
**Step 1: Add new error codes to src/types/errors.ts**

Add two new error codes to the `ErrorCode` type union under "Type validation" category:

```typescript
export type ErrorCode =
  // Parse errors
  | 'PARSE_YAML_INVALID'
  | 'PARSE_XML_INVALID'
  | 'PARSE_MISSING_FRONTMATTER'
  | 'PARSE_MISSING_BODY'
  // Structural validation
  | 'VALID_MISSING_REQUIRED_FIELD'
  | 'VALID_INVALID_FIELD_TYPE'
  | 'VALID_UNKNOWN_NODE_TYPE'
  // Reference validation
  | 'VALID_UNDEFINED_NODE_REF'
  | 'VALID_UNDEFINED_SECRET_REF'
  | 'VALID_DUPLICATE_NODE_ID'
  // Graph validation
  | 'VALID_CIRCULAR_DEPENDENCY'
  // Type validation (AI schema compatibility)
  | 'VALID_INVALID_SCHEMA'
  | 'VALID_TYPE_MISMATCH'
  // Expression errors
  | 'EXPR_PARSE_ERROR'
  | 'EXPR_EVAL_ERROR'
  | 'EXPR_UNDEFINED_VARIABLE'
  | 'EXPR_UNDEFINED_FUNCTION'
  | 'EXPR_BLOCKED_ACCESS'
  | 'EXPR_TYPE_ERROR';
```

**Step 2: Create src/validator/types.ts**

Create `src/validator/types.ts` with type compatibility validation:

```typescript
/**
 * Type Compatibility Validator
 *
 * Validates that AI node output schemas are compatible with downstream
 * node input expectations. Produces warnings (not errors) since types
 * are resolved at runtime and may still work despite static mismatches.
 */

import type { WorkflowAST, NodeAST, TransformNode, ValidationError } from '../types';
import { createWarning } from '../types/errors';
import { parseSchemaDSL, SchemaDSLError } from '../runtimes/ai/schema-dsl';
import { z } from 'zod';

/**
 * Validate type compatibility between AI nodes and their consumers.
 *
 * For each AI node with an output-schema:
 * 1. Find nodes that reference this AI node's output
 * 2. Check if the consumer has type expectations (via input attribute patterns)
 * 3. Warn if there's a potential mismatch
 *
 * @param ast - The parsed workflow AST
 * @returns Array of validation warnings
 */
export function validateTypeCompatibility(ast: WorkflowAST): ValidationError[] {
  const warnings: ValidationError[] = [];
  const nodeMap = buildNodeMap(ast.nodes);

  // Find all AI transform nodes with output schemas
  const aiNodes = findAINodesWithSchema(ast.nodes);

  for (const aiNode of aiNodes) {
    const outputSchema = aiNode.config['output-schema'];
    if (typeof outputSchema !== 'string') continue;

    // Parse the output schema
    let parsedSchema: z.ZodType;
    try {
      parsedSchema = parseSchemaDSL(outputSchema);
    } catch (e) {
      if (e instanceof SchemaDSLError) {
        warnings.push(
          createWarning(
            'VALID_INVALID_SCHEMA',
            `AI node "${aiNode.id}" has invalid output-schema: ${e.message}`,
            aiNode.loc,
            ['Check the output-schema syntax follows TypeScript-like DSL']
          )
        );
      }
      continue;
    }

    // Find consumers of this AI node
    const consumers = findConsumers(aiNode.id, ast.nodes);

    for (const consumer of consumers) {
      // Check if consumer has field access patterns that might fail
      const inputRef = consumer.input;
      if (!inputRef) continue;

      // Extract field access from input reference (e.g., "{{aiNode.output.field}}")
      const fieldAccess = extractFieldAccess(inputRef, aiNode.id);
      if (!fieldAccess) continue;

      // Validate the field exists in the output schema
      const compatibility = checkFieldCompatibility(parsedSchema, fieldAccess);
      if (!compatibility.compatible) {
        warnings.push(
          createWarning(
            'VALID_TYPE_MISMATCH',
            `Node "${consumer.id}" accesses "${fieldAccess}" from AI node "${aiNode.id}", ` +
            `but output-schema "${outputSchema}" ${compatibility.reason}`,
            consumer.loc,
            [
              `Update the output-schema to include the "${fieldAccess}" field`,
              `Or update the input reference to use an existing field`
            ]
          )
        );
      }
    }
  }

  return warnings;
}

/**
 * Build a map of node ID to node for quick lookup.
 */
function buildNodeMap(nodes: NodeAST[]): Map<string, NodeAST> {
  const map = new Map<string, NodeAST>();

  function addNodes(nodeList: NodeAST[]) {
    for (const node of nodeList) {
      map.set(node.id, node);

      // Recurse into control flow nodes
      if ('body' in node && Array.isArray(node.body)) {
        addNodes(node.body);
      }
      if ('then' in node && Array.isArray(node.then)) {
        addNodes(node.then);
      }
      if ('else' in node && Array.isArray(node.else)) {
        addNodes(node.else);
      }
      if ('cases' in node) {
        for (const c of node.cases) {
          addNodes(c.nodes);
        }
        if (node.default) {
          addNodes(node.default);
        }
      }
      if ('branches' in node) {
        for (const branch of node.branches) {
          addNodes(branch);
        }
      }
    }
  }

  addNodes(nodes);
  return map;
}

/**
 * Find all AI transform nodes that have output-schema defined.
 */
function findAINodesWithSchema(nodes: NodeAST[]): TransformNode[] {
  const aiNodes: TransformNode[] = [];

  function search(nodeList: NodeAST[]) {
    for (const node of nodeList) {
      if (
        node.type === 'transform' &&
        node.transformType === 'ai' &&
        node.config['output-schema']
      ) {
        aiNodes.push(node);
      }

      // Recurse into control flow nodes
      if ('body' in node && Array.isArray(node.body)) {
        search(node.body);
      }
      if ('then' in node && Array.isArray(node.then)) {
        search(node.then);
      }
      if ('else' in node && Array.isArray(node.else)) {
        search(node.else);
      }
      if ('cases' in node) {
        for (const c of node.cases) {
          search(c.nodes);
        }
        if (node.default) {
          search(node.default);
        }
      }
      if ('branches' in node) {
        for (const branch of node.branches) {
          search(branch);
        }
      }
    }
  }

  search(nodes);
  return aiNodes;
}

/**
 * Find all nodes that consume output from a given node ID.
 */
function findConsumers(nodeId: string, nodes: NodeAST[]): NodeAST[] {
  const consumers: NodeAST[] = [];
  const pattern = new RegExp(`\\{\\{\\s*${escapeRegex(nodeId)}\\b`);

  function search(nodeList: NodeAST[]) {
    for (const node of nodeList) {
      // Check input attribute
      if (node.input && pattern.test(node.input)) {
        consumers.push(node);
      }

      // Check config values for template references
      if ('config' in node) {
        for (const value of Object.values(node.config)) {
          if (typeof value === 'string' && pattern.test(value)) {
            consumers.push(node);
            break;
          }
        }
      }

      // Recurse into control flow nodes
      if ('body' in node && Array.isArray(node.body)) {
        search(node.body);
      }
      if ('then' in node && Array.isArray(node.then)) {
        search(node.then);
      }
      if ('else' in node && Array.isArray(node.else)) {
        search(node.else);
      }
      if ('cases' in node) {
        for (const c of node.cases) {
          search(c.nodes);
        }
        if (node.default) {
          search(node.default);
        }
      }
      if ('branches' in node) {
        for (const branch of node.branches) {
          search(branch);
        }
      }
    }
  }

  search(nodes);
  return consumers;
}

/**
 * Extract field access path from an input reference.
 *
 * For "{{nodeId.output.field.nested}}" returns "field.nested"
 * For "{{nodeId}}" returns null (whole object reference)
 */
function extractFieldAccess(inputRef: string, nodeId: string): string | null {
  // Match patterns like {{nodeId.field}} or {{nodeId.output.field}}
  const pattern = new RegExp(`\\{\\{\\s*${escapeRegex(nodeId)}\\.(?:output\\.)?([\\w.]+)\\s*\\}\\}`);
  const match = inputRef.match(pattern);

  if (match && match[1]) {
    return match[1];
  }

  return null;
}

/**
 * Check if a field path is compatible with a Zod schema.
 */
function checkFieldCompatibility(
  schema: z.ZodType,
  fieldPath: string
): { compatible: boolean; reason?: string } {
  const fields = fieldPath.split('.');

  let current: z.ZodType = schema;

  for (const field of fields) {
    // Check if current is an object type
    if (!(current instanceof z.ZodObject)) {
      return {
        compatible: false,
        reason: `does not define field "${field}" (not an object type)`
      };
    }

    // Get the shape of the object
    const shape = current.shape;
    if (!(field in shape)) {
      return {
        compatible: false,
        reason: `does not include field "${field}"`
      };
    }

    current = shape[field];
  }

  return { compatible: true };
}

/**
 * Escape special regex characters in a string.
 */
function escapeRegex(str: string): string {
  return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}
```
  </action>
  <verify>bun run typecheck</verify>
  <done>New error codes added to ErrorCode type; validateTypeCompatibility function exported from types.ts using createWarning()</done>
</task>

<task type="auto">
  <name>Task 2: Integrate type validation into main validator</name>
  <files>src/validator/index.ts</files>
  <action>
Update `src/validator/index.ts` to include type compatibility validation as Pass 4:

1. Add import at top:
```typescript
import { validateTypeCompatibility } from './types';
```

2. In the `validate` function, add Pass 4 after cycle detection:

```typescript
// Pass 4: Type compatibility validation (only if no prior errors)
const hasErrors = errors.length > 0;
if (!hasErrors) {
  const typeResults = validateTypeCompatibility(ast);
  categorizeErrors(typeResults, errors, warnings);
}
```

3. Update the JSDoc comment to mention the new pass:
```typescript
/**
 * Validate a parsed workflow AST.
 *
 * Runs multiple validation passes in order:
 * 1. Structural validation - required fields, valid types
 * 2. Reference validation - node refs, secret refs, duplicate IDs
 * 3. Cycle detection - circular dependencies
 * 4. Type compatibility - AI output schema vs consumer expectations
 *
 * @param ast - The parsed workflow AST
 * @returns ValidationResult with valid flag, errors, and warnings
 */
```

4. Add to re-exports at the end:
```typescript
export { validateTypeCompatibility } from './types';
```
  </action>
  <verify>bun run typecheck</verify>
  <done>Type compatibility validation integrated into main validate() function</done>
</task>

</tasks>

<verification>
```bash
# Type check passes
bun run typecheck

# Unit test the type validator
echo "import { parseSchemaDSL } from './src/runtimes/ai/schema-dsl.ts';
import { z } from 'zod';

// Test field compatibility check
const schema = parseSchemaDSL('{name: string, details: {score: number}}');
console.log('Schema created');

// Check if schema is ZodObject
console.log('Is ZodObject:', schema instanceof z.ZodObject);

// Check shape access
if (schema instanceof z.ZodObject) {
  console.log('Shape keys:', Object.keys(schema.shape));
}
" | bun run -

# All tests pass
bun test
```
</verification>

<success_criteria>
- [ ] `VALID_INVALID_SCHEMA` and `VALID_TYPE_MISMATCH` added to ErrorCode type
- [ ] `validateTypeCompatibility` function exported from types.ts
- [ ] Function uses `createWarning()` (not `createError()`) for all warnings
- [ ] Function finds AI nodes with output-schema
- [ ] Function identifies consumers via input references
- [ ] Function extracts field access patterns from templates
- [ ] Function checks field exists in parsed Zod schema
- [ ] Invalid output-schema syntax produces warning
- [ ] Missing field access produces warning with helpful message
- [ ] Validation integrated into main validate() as Pass 4
- [ ] `bun run typecheck` passes
- [ ] `bun test` passes
</success_criteria>

<output>
After completion, create `.planning/phases/04-ai-integration/04-04-SUMMARY.md`
</output>
