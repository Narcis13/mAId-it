---
phase: 05-transform-control-flow
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/runtimes/control/types.ts
  - src/runtimes/control/signals.ts
  - src/runtimes/transform/types.ts
autonomous: true

must_haves:
  truths:
    - "BreakSignal can be thrown and caught by loop runtimes"
    - "GotoSignal carries target node ID for executor handling"
    - "Transform config types match AST node structures"
    - "Control config types match AST node structures"
  artifacts:
    - path: "src/runtimes/control/signals.ts"
      provides: "BreakSignal and GotoSignal classes"
      exports: ["BreakSignal", "GotoSignal"]
    - path: "src/runtimes/control/types.ts"
      provides: "Control flow configuration types"
      exports: ["LoopConfig", "WhileConfig", "ForeachConfig", "BranchConfig", "IfConfig", "BreakConfig", "GotoConfig"]
    - path: "src/runtimes/transform/types.ts"
      provides: "Transform configuration types"
      exports: ["TemplateConfig", "MapConfig", "FilterConfig"]
  key_links:
    - from: "src/runtimes/control/signals.ts"
      to: "Object.setPrototypeOf"
      via: "prototype chain fix pattern"
      pattern: "Object\\.setPrototypeOf\\(this"
---

<objective>
Create the type foundation for transform and control flow runtimes.

Purpose: Establish control flow signals (BreakSignal, GotoSignal) and configuration types that all subsequent runtime implementations will use. This is the foundation layer that other plans depend on.

Output:
- `src/runtimes/control/signals.ts` - Control flow exception signals
- `src/runtimes/control/types.ts` - Control flow configuration types
- `src/runtimes/transform/types.ts` - Transform configuration types
</objective>

<execution_context>
@/Users/narcisbrindusescu/.claude/looppool/workflows/execute-plan.md
@/Users/narcisbrindusescu/.claude/looppool/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-transform-control-flow/05-RESEARCH.md

Reference for existing patterns:
@src/runtimes/types.ts
@src/runtimes/errors.ts
@src/types/ast.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create control flow signal classes</name>
  <files>src/runtimes/control/signals.ts</files>
  <action>
Create BreakSignal and GotoSignal classes following the existing error pattern in src/runtimes/errors.ts.

BreakSignal:
- Extends Error
- Constructor takes optional targetLoopId: string (for breaking specific outer loops)
- Sets this.name = 'BreakSignal'
- Uses Object.setPrototypeOf(this, BreakSignal.prototype) for proper instanceof behavior
- Message format: targetLoopId ? `Break to loop: ${targetLoopId}` : 'Break'

GotoSignal:
- Extends Error
- Constructor takes required targetNodeId: string
- Sets this.name = 'GotoSignal'
- Uses Object.setPrototypeOf(this, GotoSignal.prototype) for proper instanceof behavior
- Message format: `Goto: ${targetNodeId}`

Both should be exported as named exports.
  </action>
  <verify>bun build src/runtimes/control/signals.ts --no-bundle</verify>
  <done>
- BreakSignal class exists with optional targetLoopId property
- GotoSignal class exists with required targetNodeId property
- Both use Object.setPrototypeOf pattern for proper prototype chain
- File compiles without TypeScript errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Create control flow configuration types</name>
  <files>src/runtimes/control/types.ts</files>
  <action>
Create configuration interfaces matching the AST node structures from src/types/ast.ts.

LoopConfig:
- maxIterations?: number (default will be 1000 in runtime)
- breakCondition?: string (expression)

WhileConfig:
- condition: string (required - loop while true)
- maxIterations?: number (safety bound, default 1000)

ForeachConfig:
- collection: string (expression evaluating to array)
- itemVar?: string (variable name for current item, default 'item')
- indexVar?: string (variable name for index, default 'index')
- maxConcurrency?: number (default 1 = sequential)

BranchConfig:
- (empty - cases are in AST node structure, not config)

IfConfig:
- condition: string (required)

BreakConfig:
- loop?: string (optional target loop ID)

GotoConfig:
- target: string (required target node ID)

Also export DEFAULT_MAX_ITERATIONS = 1000 constant.
  </action>
  <verify>bun build src/runtimes/control/types.ts --no-bundle</verify>
  <done>
- All config interfaces match corresponding AST node structures
- DEFAULT_MAX_ITERATIONS constant exported
- File compiles without TypeScript errors
  </done>
</task>

<task type="auto">
  <name>Task 3: Create transform configuration types</name>
  <files>src/runtimes/transform/types.ts</files>
  <action>
Create configuration interfaces for transform nodes.

TemplateConfig:
- template: string (template string with {{expression}} placeholders)

MapConfig:
- expression: string (expression to evaluate for each item)
- Expression has access to $item, $index, $first, $last, $items

FilterConfig:
- condition: string (expression that must return truthy for item to be included)
- Expression has access to $item, $index

Add JSDoc comments explaining the iteration context variables available in each config type.
  </action>
  <verify>bun build src/runtimes/transform/types.ts --no-bundle</verify>
  <done>
- TemplateConfig, MapConfig, FilterConfig interfaces exist
- JSDoc documents available iteration context variables
- File compiles without TypeScript errors
  </done>
</task>

</tasks>

<verification>
All foundation types are in place:
1. `bun build src/runtimes/control/signals.ts --no-bundle` succeeds
2. `bun build src/runtimes/control/types.ts --no-bundle` succeeds
3. `bun build src/runtimes/transform/types.ts --no-bundle` succeeds
4. Files follow existing codebase conventions (Object.setPrototypeOf, JSDoc comments)
</verification>

<success_criteria>
- Control flow signals (BreakSignal, GotoSignal) can be instantiated and thrown
- All config types match their corresponding AST node structures
- DEFAULT_MAX_ITERATIONS constant available for loop safety bounds
- No TypeScript compilation errors
</success_criteria>

<output>
After completion, create `.planning/phases/05-transform-control-flow/05-01-SUMMARY.md`
</output>
