---
phase: 05-transform-control-flow
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - src/runtimes/transform/template.ts
  - src/runtimes/transform/map.ts
  - src/runtimes/transform/filter.ts
  - src/runtimes/transform/index.ts
autonomous: true

must_haves:
  truths:
    - "Template node renders {{expression}} placeholders to strings"
    - "Map node transforms each array item using expression with $item context"
    - "Filter node returns items where condition expression is truthy"
    - "All transforms use existing evaluate() and evaluateTemplate() functions"
  artifacts:
    - path: "src/runtimes/transform/template.ts"
      provides: "Template node runtime"
      exports: ["templateRuntime"]
    - path: "src/runtimes/transform/map.ts"
      provides: "Map node runtime"
      exports: ["mapRuntime"]
    - path: "src/runtimes/transform/filter.ts"
      provides: "Filter node runtime"
      exports: ["filterRuntime"]
    - path: "src/runtimes/transform/index.ts"
      provides: "Transform module exports"
      exports: ["templateRuntime", "mapRuntime", "filterRuntime"]
  key_links:
    - from: "src/runtimes/transform/template.ts"
      to: "src/expression/index.ts"
      via: "evaluateTemplate import"
      pattern: "import.*evaluateTemplate.*from"
    - from: "src/runtimes/transform/map.ts"
      to: "src/expression/index.ts"
      via: "evaluate and buildEvaluationContext imports"
      pattern: "import.*evaluate.*from"
---

<objective>
Implement transform node runtimes (Template, Map, Filter).

Purpose: Enable data transformation in workflows - rendering templates, transforming arrays via map, and filtering arrays by condition. These are the data manipulation primitives that complement source/sink nodes.

Output:
- `src/runtimes/transform/template.ts` - Template string rendering
- `src/runtimes/transform/map.ts` - Array transformation
- `src/runtimes/transform/filter.ts` - Array filtering
- `src/runtimes/transform/index.ts` - Module exports
</objective>

<execution_context>
@/Users/narcisbrindusescu/.claude/looppool/workflows/execute-plan.md
@/Users/narcisbrindusescu/.claude/looppool/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-transform-control-flow/05-RESEARCH.md

Reference files:
@src/runtimes/types.ts (NodeRuntime interface)
@src/expression/index.ts (evaluate, evaluateTemplate, buildEvaluationContext)
@src/expression/context.ts (buildEvaluationContext implementation)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create template runtime</name>
  <files>src/runtimes/transform/template.ts</files>
  <action>
Implement templateRuntime following the NodeRuntime interface pattern.

Implementation:
- Import NodeRuntime, ExecutionParams from '../types.ts'
- Import evaluateTemplate, buildEvaluationContext from '../../expression'
- Import TemplateConfig from './types.ts'

templateRuntime: NodeRuntime<TemplateConfig, unknown, string>
- type: 'transform:template'
- execute method:
  1. Add input to nodeContext: state.nodeContext = { ...state.nodeContext, input }
  2. Build evaluation context via buildEvaluationContext(state)
  3. Return evaluateTemplate(config.template, context)

The input is added to context so templates can reference {{input}} or {{input.field}}.
  </action>
  <verify>bun build src/runtimes/transform/template.ts --no-bundle</verify>
  <done>
- templateRuntime implements NodeRuntime interface
- Template expressions can access input via {{input}}
- Uses existing evaluateTemplate() for rendering
  </done>
</task>

<task type="auto">
  <name>Task 2: Create map and filter runtimes</name>
  <files>src/runtimes/transform/map.ts, src/runtimes/transform/filter.ts</files>
  <action>
Implement mapRuntime and filterRuntime following context injection pattern from research.

mapRuntime: NodeRuntime<MapConfig, unknown[], unknown[]>
- type: 'transform:map'
- execute method:
  1. Coerce input to array: const items = Array.isArray(input) ? input : [input]
  2. Get base context via buildEvaluationContext(state)
  3. For each item at index i, create itemContext by spreading base variables and adding:
     - $item: items[i]
     - $index: i
     - $first: i === 0
     - $last: i === items.length - 1
     - $items: items (the full array)
  4. Evaluate config.expression with itemContext
  5. Collect results into array and return

filterRuntime: NodeRuntime<FilterConfig, unknown[], unknown[]>
- type: 'transform:filter'
- execute method:
  1. Coerce input to array: const items = Array.isArray(input) ? input : [input]
  2. Get base context via buildEvaluationContext(state)
  3. For each item at index i, create itemContext with $item, $index
  4. Evaluate config.condition with itemContext
  5. If result is truthy, push the ORIGINAL ITEM (not the boolean) to results
  6. Return filtered array

IMPORTANT for filter: Push items[i], not the condition result. Filter selects items, doesn't transform them.
  </action>
  <verify>bun build src/runtimes/transform/map.ts --no-bundle && bun build src/runtimes/transform/filter.ts --no-bundle</verify>
  <done>
- mapRuntime transforms each item using expression
- filterRuntime includes items where condition is truthy
- Both inject $item, $index into evaluation context
- Filter returns original items, not booleans
  </done>
</task>

<task type="auto">
  <name>Task 3: Create transform module index</name>
  <files>src/runtimes/transform/index.ts</files>
  <action>
Create the module index file that exports all transform runtimes and types.

Exports:
- Re-export all types from './types.ts'
- Export templateRuntime from './template.ts'
- Export mapRuntime from './map.ts'
- Export filterRuntime from './filter.ts'

Add a module JSDoc comment explaining the transform runtimes purpose.
  </action>
  <verify>bun build src/runtimes/transform/index.ts --no-bundle</verify>
  <done>
- All transform runtimes exported from single index
- Types re-exported
- Module compiles without errors
  </done>
</task>

</tasks>

<verification>
Transform runtimes are complete:
1. `bun build src/runtimes/transform/index.ts --no-bundle` succeeds
2. All three runtimes implement NodeRuntime interface
3. Imports from expression module resolve correctly
</verification>

<success_criteria>
- Template runtime renders {{expression}} placeholders using evaluateTemplate()
- Map runtime transforms each array item with $item/$index context injection
- Filter runtime returns items where condition is truthy (not the boolean results)
- All runtimes follow established NodeRuntime pattern
- No TypeScript compilation errors
</success_criteria>

<output>
After completion, create `.planning/phases/05-transform-control-flow/05-02-SUMMARY.md`
</output>
