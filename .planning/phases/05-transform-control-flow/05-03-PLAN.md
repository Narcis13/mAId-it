---
phase: 05-transform-control-flow
plan: 03
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - src/runtimes/control/branch.ts
  - src/runtimes/control/if.ts
  - src/runtimes/control/loop.ts
  - src/runtimes/control/while.ts
  - src/runtimes/control/foreach.ts
  - src/runtimes/control/break.ts
  - src/runtimes/control/goto.ts
  - src/runtimes/control/index.ts
autonomous: true

must_haves:
  truths:
    - "Branch node executes first matching case or default"
    - "If node executes then branch when condition truthy, else branch otherwise"
    - "Loop node iterates up to maxIterations, respects breakCondition"
    - "While node iterates while condition is true, respects maxIterations safety bound"
    - "Foreach node iterates over collection with item/index context injection"
    - "Break node throws BreakSignal caught by enclosing loop"
    - "Goto node throws GotoSignal for executor handling"
  artifacts:
    - path: "src/runtimes/control/branch.ts"
      provides: "Branch node runtime"
      exports: ["branchRuntime"]
    - path: "src/runtimes/control/if.ts"
      provides: "If node runtime"
      exports: ["ifRuntime"]
    - path: "src/runtimes/control/loop.ts"
      provides: "Loop node runtime"
      exports: ["loopRuntime"]
    - path: "src/runtimes/control/while.ts"
      provides: "While node runtime"
      exports: ["whileRuntime"]
    - path: "src/runtimes/control/foreach.ts"
      provides: "Foreach node runtime"
      exports: ["foreachRuntime"]
    - path: "src/runtimes/control/break.ts"
      provides: "Break node runtime"
      exports: ["breakRuntime"]
    - path: "src/runtimes/control/goto.ts"
      provides: "Goto node runtime"
      exports: ["gotoRuntime"]
    - path: "src/runtimes/control/index.ts"
      provides: "Control module exports"
      exports: ["branchRuntime", "ifRuntime", "loopRuntime", "whileRuntime", "foreachRuntime", "breakRuntime", "gotoRuntime"]
  key_links:
    - from: "src/runtimes/control/loop.ts"
      to: "src/runtimes/control/signals.ts"
      via: "BreakSignal catch"
      pattern: "instanceof BreakSignal"
    - from: "src/runtimes/control/break.ts"
      to: "src/runtimes/control/signals.ts"
      via: "BreakSignal throw"
      pattern: "throw new BreakSignal"
    - from: "src/runtimes/control/goto.ts"
      to: "src/runtimes/control/signals.ts"
      via: "GotoSignal throw"
      pattern: "throw new GotoSignal"
---

<objective>
Implement control flow node runtimes (Branch, If, Loop, While, Foreach, Break, Goto).

Purpose: Enable workflow control flow - conditional branching, loops with various patterns, and flow control statements. These primitives allow workflows to make decisions and repeat operations.

Output:
- `src/runtimes/control/branch.ts` - Pattern matching branching
- `src/runtimes/control/if.ts` - Simple conditional
- `src/runtimes/control/loop.ts` - Fixed iteration loop
- `src/runtimes/control/while.ts` - Condition-based loop
- `src/runtimes/control/foreach.ts` - Collection iteration
- `src/runtimes/control/break.ts` - Loop exit
- `src/runtimes/control/goto.ts` - Node jump
- `src/runtimes/control/index.ts` - Module exports
</objective>

<execution_context>
@/Users/narcisbrindusescu/.claude/looppool/workflows/execute-plan.md
@/Users/narcisbrindusescu/.claude/looppool/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-transform-control-flow/05-RESEARCH.md

Reference files:
@src/runtimes/types.ts (NodeRuntime interface)
@src/types/ast.ts (BranchNode, IfNode, LoopNode, etc.)
@src/expression/index.ts (evaluate, buildEvaluationContext)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create branch and if runtimes</name>
  <files>src/runtimes/control/branch.ts, src/runtimes/control/if.ts</files>
  <action>
Implement conditional control flow runtimes.

branchRuntime: NodeRuntime<BranchConfig, unknown, unknown>
- type: 'control:branch'
- execute method:
  1. Cast node to BranchNode to access cases and default
  2. Build evaluation context from state
  3. Iterate through branchNode.cases in order
  4. For each case, evaluate case.condition - if truthy, return input (body execution is executor's job)
  5. If no case matched and branchNode.default exists, return input
  6. If no match and no default, return input unchanged

IMPORTANT: Branch runtime does NOT execute body nodes directly. It returns the input and sets state metadata to indicate which branch was taken. The executor handles body execution based on AST structure.

For now, return a result object: { matched: true, caseIndex: number } or { matched: false, useDefault: true/false }. This tells the executor which path to take.

ifRuntime: NodeRuntime<IfConfig, unknown, unknown>
- type: 'control:if'
- execute method:
  1. Cast node to IfNode to access then/else
  2. Build evaluation context from state
  3. Evaluate config.condition (or node.condition from AST)
  4. Return { condition: boolean } - executor handles then/else body execution

Note: The actual condition is on the IfNode AST, not in config. Read from node.condition.
  </action>
  <verify>bun build src/runtimes/control/branch.ts --no-bundle && bun build src/runtimes/control/if.ts --no-bundle</verify>
  <done>
- branchRuntime evaluates cases and returns match info
- ifRuntime evaluates condition and returns result
- Both delegate body execution to executor
  </done>
</task>

<task type="auto">
  <name>Task 2: Create loop, while, and foreach runtimes</name>
  <files>src/runtimes/control/loop.ts, src/runtimes/control/while.ts, src/runtimes/control/foreach.ts</files>
  <action>
Implement iteration control flow runtimes.

loopRuntime: NodeRuntime<LoopConfig, unknown, unknown>
- type: 'control:loop'
- execute method:
  1. Get maxIterations from config or DEFAULT_MAX_ITERATIONS (1000)
  2. Get breakCondition from node.breakCondition (AST) or config.breakCondition
  3. For now, return { maxIterations, breakCondition, bodyNodeIds: node.body.map(n => n.id) }
  4. The executor will handle the actual iteration and body execution

Note: Loop runtimes prepare iteration metadata. Actual iteration happens in executor layer which has access to executeNodes().

whileRuntime: NodeRuntime<WhileConfig, unknown, unknown>
- type: 'control:while'
- execute method:
  1. Get condition from node.condition (AST) or config.condition
  2. Get maxIterations from config or DEFAULT_MAX_ITERATIONS
  3. Return { condition, maxIterations, bodyNodeIds: node.body.map(n => n.id) }

foreachRuntime: NodeRuntime<ForeachConfig, unknown, unknown>
- type: 'control:foreach'
- execute method:
  1. Evaluate node.collection expression to get the array
  2. Get itemVar from node.itemVar or config.itemVar or 'item'
  3. Get indexVar from config.indexVar or 'index'
  4. Return { collection: evaluatedArray, itemVar, indexVar, bodyNodeIds: node.body.map(n => n.id) }

The executor uses this metadata to iterate, injecting item/index into context for each iteration.
  </action>
  <verify>bun build src/runtimes/control/loop.ts --no-bundle && bun build src/runtimes/control/while.ts --no-bundle && bun build src/runtimes/control/foreach.ts --no-bundle</verify>
  <done>
- loopRuntime returns iteration metadata with maxIterations
- whileRuntime returns condition and maxIterations
- foreachRuntime evaluates collection and returns iteration metadata
- All respect DEFAULT_MAX_ITERATIONS safety bound
  </done>
</task>

<task type="auto">
  <name>Task 3: Create break, goto runtimes and module index</name>
  <files>src/runtimes/control/break.ts, src/runtimes/control/goto.ts, src/runtimes/control/index.ts</files>
  <action>
Implement flow control statement runtimes and module index.

breakRuntime: NodeRuntime<BreakConfig, unknown, never>
- type: 'control:break'
- execute method:
  1. Get target loop ID from config.loop if specified
  2. throw new BreakSignal(config.loop)
  3. Return type is 'never' because it always throws

gotoRuntime: NodeRuntime<GotoConfig, unknown, never>
- type: 'control:goto'
- execute method:
  1. Get target node ID from config.target (required)
  2. throw new GotoSignal(config.target)
  3. Return type is 'never' because it always throws

index.ts:
- Re-export all types from './types.ts'
- Re-export signals from './signals.ts'
- Export all runtimes: branchRuntime, ifRuntime, loopRuntime, whileRuntime, foreachRuntime, breakRuntime, gotoRuntime
- Add module JSDoc explaining control flow runtimes
  </action>
  <verify>bun build src/runtimes/control/break.ts --no-bundle && bun build src/runtimes/control/goto.ts --no-bundle && bun build src/runtimes/control/index.ts --no-bundle</verify>
  <done>
- breakRuntime throws BreakSignal
- gotoRuntime throws GotoSignal
- Module index exports all runtimes and types
  </done>
</task>

</tasks>

<verification>
Control flow runtimes are complete:
1. `bun build src/runtimes/control/index.ts --no-bundle` succeeds
2. All runtimes implement NodeRuntime interface
3. Break and Goto throw appropriate signals
4. Iteration runtimes return metadata, not execute bodies directly
</verification>

<success_criteria>
- Branch runtime evaluates cases in order, returns match info
- If runtime evaluates condition, returns boolean result
- Loop/While/Foreach runtimes return iteration metadata with safety bounds
- Break runtime throws BreakSignal with optional target loop
- Goto runtime throws GotoSignal with target node ID
- All runtimes follow established NodeRuntime pattern
- No TypeScript compilation errors
</success_criteria>

<output>
After completion, create `.planning/phases/05-transform-control-flow/05-03-SUMMARY.md`
</output>
