---
phase: 06-scheduling-parallelism
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/scheduler/types.ts
  - src/scheduler/concurrency.ts
  - src/scheduler/dag.ts
  - src/scheduler/waves.ts
  - src/scheduler/index.ts
autonomous: true

must_haves:
  truths:
    - Semaphore limits concurrent async operations to configured capacity
    - DAG builder extracts dependencies from node input references
    - Wave computation groups independent nodes into parallel waves
    - Nodes with no dependencies are in wave 0
    - Nodes depending only on wave 0 nodes are in wave 1
  artifacts:
    - src/scheduler/types.ts (ExecutionPlan, ExecutionWave, ExecutionOptions)
    - src/scheduler/concurrency.ts (Semaphore class)
    - src/scheduler/dag.ts (buildDependencyGraph)
    - src/scheduler/waves.ts (computeWaves)
    - src/scheduler/index.ts (exports)
  key_links:
    - types.ts defines ExecutionWave used by waves.ts
    - dag.ts buildDependencyGraph output feeds into waves.ts computeWaves
    - index.ts exports buildExecutionPlan which uses both dag.ts and waves.ts
---

<objective>
Create the scheduler infrastructure: type definitions, concurrency semaphore, and DAG/wave computation using Kahn's algorithm.

Purpose: Provides the foundation for parallel execution by computing which nodes can run concurrently based on their dependencies.

Output: Complete scheduler module with types, semaphore, and wave computation ready for executor integration.
</objective>

<execution_context>
@/Users/narcisbrindusescu/.claude/looppool/workflows/execute-plan.md
@/Users/narcisbrindusescu/.claude/looppool/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-scheduling-parallelism/06-RESEARCH.md

# Existing patterns to follow
@src/execution/types.ts
@src/validator/cycles.ts
@src/types/ast.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create scheduler types</name>
  <files>src/scheduler/types.ts</files>
  <action>
Create type definitions for the scheduler module:

```typescript
/**
 * Scheduler Type Definitions for FlowScript
 *
 * Types for execution planning, waves, and concurrency options.
 */

import type { NodeAST } from '../types/ast';

/**
 * A wave of nodes that can execute in parallel.
 */
export interface ExecutionWave {
  /** Wave number (0-indexed, execution order) */
  waveNumber: number;
  /** Node IDs in this wave (can all run in parallel) */
  nodeIds: string[];
}

/**
 * Complete execution plan for a workflow.
 */
export interface ExecutionPlan {
  /** Workflow ID being executed */
  workflowId: string;
  /** Total number of top-level nodes */
  totalNodes: number;
  /** Execution waves in order */
  waves: ExecutionWave[];
  /** Node lookup map for quick access */
  nodes: Map<string, NodeAST>;
}

/**
 * Options for workflow execution.
 */
export interface ExecutionOptions {
  /** Maximum concurrent node executions per wave (default: 10) */
  maxConcurrency?: number;
  /** Global timeout in milliseconds (default: none) */
  timeout?: number;
}

/** Default maximum concurrency per wave */
export const DEFAULT_MAX_CONCURRENCY = 10;
```
  </action>
  <verify>bun build src/scheduler/types.ts --no-bundle 2>&1 | head -5</verify>
  <done>Types compile without errors and define ExecutionWave, ExecutionPlan, ExecutionOptions</done>
</task>

<task type="auto">
  <name>Task 2: Implement Semaphore for concurrency limiting</name>
  <files>src/scheduler/concurrency.ts</files>
  <action>
Implement a semaphore class for limiting concurrent async operations:

```typescript
/**
 * Concurrency Control for FlowScript Scheduler
 *
 * Provides Semaphore class for limiting concurrent async operations.
 */

/**
 * Semaphore for limiting concurrent async operations.
 *
 * @example
 * ```typescript
 * const sem = new Semaphore(3); // max 3 concurrent
 *
 * async function limitedTask() {
 *   await sem.acquire();
 *   try {
 *     await doWork();
 *   } finally {
 *     sem.release();
 *   }
 * }
 * ```
 */
export class Semaphore {
  private permits: number;
  private waitQueue: Array<() => void> = [];

  /**
   * Create a semaphore with the given capacity.
   * @param capacity Maximum concurrent permits (must be >= 1)
   */
  constructor(private readonly capacity: number) {
    if (capacity < 1) {
      throw new Error('Semaphore capacity must be at least 1');
    }
    this.permits = capacity;
  }

  /**
   * Acquire a permit. Blocks (awaits) if none available.
   */
  async acquire(): Promise<void> {
    if (this.permits > 0) {
      this.permits--;
      return;
    }

    // Wait for a permit to become available
    return new Promise<void>((resolve) => {
      this.waitQueue.push(resolve);
    });
  }

  /**
   * Release a permit, allowing next waiting task to proceed.
   * Must be called after acquire, typically in a finally block.
   */
  release(): void {
    const next = this.waitQueue.shift();
    if (next) {
      // Give permit directly to next waiter (don't increment permits)
      next();
    } else {
      // Return permit to pool
      this.permits++;
    }
  }

  /**
   * Number of currently available permits.
   */
  get available(): number {
    return this.permits;
  }

  /**
   * Number of tasks waiting for permits.
   */
  get waiting(): number {
    return this.waitQueue.length;
  }
}
```
  </action>
  <verify>bun build src/scheduler/concurrency.ts --no-bundle 2>&1 | head -5</verify>
  <done>Semaphore class compiles and has acquire(), release(), available, waiting members</done>
</task>

<task type="auto">
  <name>Task 3: Implement DAG building and wave computation</name>
  <files>src/scheduler/dag.ts, src/scheduler/waves.ts, src/scheduler/index.ts</files>
  <action>
Create DAG builder in `src/scheduler/dag.ts`:

```typescript
/**
 * DAG Builder for FlowScript Scheduler
 *
 * Extracts dependencies from AST nodes to build a directed acyclic graph.
 */

import type { NodeAST } from '../types/ast';

/**
 * Build a dependency graph from workflow nodes.
 * Maps each node ID to the set of node IDs it depends on (via input).
 *
 * Only top-level nodes participate in wave scheduling.
 * Control flow nodes (loop, if, parallel) handle their body execution internally.
 *
 * @param nodes Top-level nodes from WorkflowAST
 * @returns Map of nodeId -> Set of dependency nodeIds
 */
export function buildDependencyGraph(nodes: NodeAST[]): Map<string, Set<string>> {
  const graph = new Map<string, Set<string>>();

  // Initialize all nodes with empty dependency sets
  for (const node of nodes) {
    graph.set(node.id, new Set());
  }

  // Add dependencies from input references
  for (const node of nodes) {
    if (node.input) {
      const deps = graph.get(node.id);
      if (deps) {
        deps.add(node.input);
      }
    }
  }

  return graph;
}
```

Create wave computation in `src/scheduler/waves.ts`:

```typescript
/**
 * Wave Computation for FlowScript Scheduler
 *
 * Uses Kahn's algorithm to compute execution waves from dependency graph.
 */

import type { NodeAST } from '../types/ast';
import type { ExecutionWave } from './types';

/**
 * Compute execution waves from dependency graph using Kahn's algorithm.
 *
 * Nodes with no dependencies form wave 0.
 * Nodes whose dependencies are all in earlier waves form the next wave.
 * Continues until all nodes are assigned to waves.
 *
 * @param nodes Array of nodes to schedule
 * @param dependencies Map of nodeId -> Set of dependency nodeIds
 * @returns Array of execution waves in order
 * @throws Error if cycle detected (shouldn't happen if validator ran)
 */
export function computeWaves(
  nodes: NodeAST[],
  dependencies: Map<string, Set<string>>
): ExecutionWave[] {
  const waves: ExecutionWave[] = [];
  const remaining = new Set(nodes.map((n) => n.id));
  const completed = new Set<string>();
  let waveNumber = 0;

  while (remaining.size > 0) {
    // Find all nodes with no unmet dependencies
    const ready: string[] = [];

    for (const nodeId of remaining) {
      const deps = dependencies.get(nodeId) ?? new Set();
      const unmetDeps = [...deps].filter((d) => !completed.has(d));

      if (unmetDeps.length === 0) {
        ready.push(nodeId);
      }
    }

    // Cycle detection (shouldn't happen if validator caught cycles)
    if (ready.length === 0 && remaining.size > 0) {
      const remainingIds = [...remaining].join(', ');
      throw new Error(`Cycle detected in dependency graph: ${remainingIds}`);
    }

    // All ready nodes form this wave
    waves.push({ waveNumber, nodeIds: ready });

    // Mark as completed and remove from remaining
    for (const nodeId of ready) {
      completed.add(nodeId);
      remaining.delete(nodeId);
    }

    waveNumber++;
  }

  return waves;
}
```

Create main index with buildExecutionPlan in `src/scheduler/index.ts`:

```typescript
/**
 * Scheduler Module for FlowScript
 *
 * Builds execution plans from workflow AST, computing waves for parallel execution.
 */

import type { WorkflowAST, NodeAST } from '../types/ast';
import type { ExecutionPlan } from './types';
import { buildDependencyGraph } from './dag';
import { computeWaves } from './waves';

// Re-export types and utilities
export * from './types';
export * from './concurrency';
export { buildDependencyGraph } from './dag';
export { computeWaves } from './waves';

/**
 * Build an execution plan from a workflow AST.
 *
 * Analyzes node dependencies to compute execution waves.
 * Nodes in the same wave have no dependencies on each other and can run in parallel.
 *
 * @param ast Parsed workflow AST
 * @returns Execution plan with waves and node lookup
 *
 * @example
 * ```typescript
 * const plan = buildExecutionPlan(ast);
 * console.log(`${plan.waves.length} waves for ${plan.totalNodes} nodes`);
 * ```
 */
export function buildExecutionPlan(ast: WorkflowAST): ExecutionPlan {
  const nodes = new Map<string, NodeAST>();

  // Build node lookup from top-level nodes
  for (const node of ast.nodes) {
    nodes.set(node.id, node);
  }

  // Build dependency graph and compute waves
  const dependencies = buildDependencyGraph(ast.nodes);
  const waves = computeWaves(ast.nodes, dependencies);

  return {
    workflowId: ast.metadata.name,
    totalNodes: nodes.size,
    waves,
    nodes,
  };
}
```
  </action>
  <verify>bun build src/scheduler/index.ts --no-bundle 2>&1 | head -5</verify>
  <done>Module compiles and exports buildExecutionPlan, Semaphore, types</done>
</task>

</tasks>

<verification>
```bash
# Verify all files exist
ls -la src/scheduler/

# Verify module compiles
bun build src/scheduler/index.ts --no-bundle

# Verify types are exported
bun -e "import { ExecutionPlan, ExecutionWave, Semaphore, buildExecutionPlan } from './src/scheduler'; console.log('Exports OK')"
```
</verification>

<success_criteria>
- [ ] src/scheduler/types.ts defines ExecutionPlan, ExecutionWave, ExecutionOptions
- [ ] src/scheduler/concurrency.ts exports Semaphore class with acquire/release
- [ ] src/scheduler/dag.ts exports buildDependencyGraph function
- [ ] src/scheduler/waves.ts exports computeWaves function
- [ ] src/scheduler/index.ts exports buildExecutionPlan and all utilities
- [ ] All files compile without TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/06-scheduling-parallelism/06-01-SUMMARY.md`
</output>
