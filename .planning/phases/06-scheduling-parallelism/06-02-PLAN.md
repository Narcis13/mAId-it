---
phase: 06-scheduling-parallelism
plan: 02
type: execute
wave: 2
depends_on: [06-01]
files_modified:
  - src/execution/executor.ts
  - src/execution/state.ts
  - src/execution/index.ts
  - src/scheduler/scheduler.test.ts
autonomous: true

must_haves:
  truths:
    - Executor processes waves sequentially in order
    - Nodes within a wave run concurrently up to maxConcurrency
    - Semaphore prevents more than maxConcurrency concurrent executions
    - State cloning provides isolation for parallel node execution
    - Node results are recorded after each node completes
    - Failed node stops wave execution (fail-fast)
  artifacts:
    - src/execution/executor.ts (execute, executeWave functions)
    - src/execution/state.ts (cloneStateForNode function added)
    - src/scheduler/scheduler.test.ts (wave computation and semaphore tests)
  key_links:
    - executor.ts uses Semaphore from scheduler/concurrency.ts
    - executor.ts uses ExecutionPlan from scheduler/types.ts
    - executor.ts calls runtime.execute via registry.getRuntime
---

<objective>
Implement the executor that processes execution plans by running waves with concurrency control.

Purpose: The executor is the engine that actually runs workflows, processing nodes wave by wave with configurable parallelism.

Output: Working executor that can run waves concurrently, plus tests validating scheduler/semaphore behavior.
</objective>

<execution_context>
@/Users/narcisbrindusescu/.claude/looppool/workflows/execute-plan.md
@/Users/narcisbrindusescu/.claude/looppool/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-scheduling-parallelism/06-RESEARCH.md

# Dependencies from 06-01
@src/scheduler/types.ts
@src/scheduler/concurrency.ts
@src/scheduler/index.ts

# Existing patterns
@src/execution/types.ts
@src/execution/state.ts
@src/runtimes/registry.ts
@src/runtimes/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add state cloning utility</name>
  <files>src/execution/state.ts</files>
  <action>
Add a function to clone execution state for parallel node isolation. Read the existing file first, then add:

```typescript
/**
 * Clone execution state for parallel node execution.
 *
 * Creates a new state object with deep-cloned nodeContext to prevent
 * parallel nodes from affecting each other's context.
 *
 * Note: nodeResults is shared intentionally - results are written by nodeId
 * which provides natural isolation.
 *
 * @param state Original execution state
 * @param contextOverrides Optional context values to add/override
 * @returns Cloned state safe for parallel execution
 */
export function cloneStateForNode(
  state: ExecutionState,
  contextOverrides?: Record<string, unknown>
): ExecutionState {
  return {
    ...state,
    // Deep clone nodeContext to prevent parallel mutation issues
    nodeContext: {
      ...structuredClone(state.nodeContext),
      ...contextOverrides,
    },
    // phaseContext and globalContext are read-only during execution
    phaseContext: { ...state.phaseContext },
    globalContext: { ...state.globalContext },
    // nodeResults is shared - writes are isolated by nodeId key
    nodeResults: state.nodeResults,
    // config and secrets are read-only
    config: state.config,
    secrets: state.secrets,
  };
}
```

Also add export to the file's exports.
  </action>
  <verify>bun build src/execution/state.ts --no-bundle 2>&1 | head -5</verify>
  <done>cloneStateForNode function added and compiles</done>
</task>

<task type="auto">
  <name>Task 2: Implement executor with wave processing</name>
  <files>src/execution/executor.ts</files>
  <action>
Create the executor that processes execution plans:

```typescript
/**
 * Workflow Executor for FlowScript
 *
 * Executes workflow plans by processing waves with concurrency control.
 */

import type { NodeAST } from '../types/ast';
import type { ExecutionState, NodeResult } from './types';
import type { ExecutionPlan, ExecutionWave, ExecutionOptions } from '../scheduler/types';
import { Semaphore, DEFAULT_MAX_CONCURRENCY } from '../scheduler/concurrency';
import { getRuntime, hasRuntime } from '../runtimes/registry';
import { cloneStateForNode } from './state';
import { evaluateInContext, resolveTemplateValue } from './index';

/**
 * Execute a workflow plan.
 *
 * Processes waves sequentially, running nodes within each wave
 * concurrently up to the configured maxConcurrency limit.
 *
 * @param plan Execution plan from buildExecutionPlan
 * @param state Initialized execution state
 * @param options Execution options (maxConcurrency, timeout)
 *
 * @example
 * ```typescript
 * const plan = buildExecutionPlan(ast);
 * const state = createExecutionState({ workflowId: ast.metadata.name });
 * await execute(plan, state, { maxConcurrency: 5 });
 * ```
 */
export async function execute(
  plan: ExecutionPlan,
  state: ExecutionState,
  options: ExecutionOptions = {}
): Promise<void> {
  const maxConcurrency = options.maxConcurrency ?? DEFAULT_MAX_CONCURRENCY;

  state.status = 'running';

  try {
    // Process waves sequentially
    for (const wave of plan.waves) {
      state.currentWave = wave.waveNumber;
      await executeWave(wave, plan.nodes, state, maxConcurrency);
    }

    state.status = 'completed';
    state.completedAt = Date.now();
  } catch (error) {
    state.status = 'failed';
    state.completedAt = Date.now();
    throw error;
  }
}

/**
 * Execute a single wave with concurrency limiting.
 *
 * All nodes in the wave start execution, but only maxConcurrency
 * will actually run at once (others wait for semaphore).
 *
 * Uses fail-fast: first error stops the wave and throws.
 */
async function executeWave(
  wave: ExecutionWave,
  nodes: Map<string, NodeAST>,
  state: ExecutionState,
  maxConcurrency: number
): Promise<void> {
  const semaphore = new Semaphore(maxConcurrency);
  const errors: Error[] = [];

  const executions = wave.nodeIds.map(async (nodeId) => {
    await semaphore.acquire();
    try {
      const node = nodes.get(nodeId);
      if (!node) {
        throw new Error(`Node not found: ${nodeId}`);
      }

      // Execute the node and record result
      const result = await executeNode(node, state);
      recordNodeResult(state, nodeId, result);
    } catch (error) {
      errors.push(error as Error);
    } finally {
      semaphore.release();
    }
  });

  await Promise.all(executions);

  // Fail-fast: throw first error encountered
  if (errors.length > 0) {
    throw errors[0];
  }
}

/**
 * Execute a single node.
 *
 * Resolves input from previous node, gets the runtime, and executes.
 */
async function executeNode(
  node: NodeAST,
  state: ExecutionState
): Promise<NodeResult> {
  const startedAt = Date.now();

  try {
    // Resolve input from previous node if specified
    let input: unknown = undefined;
    if (node.input) {
      const prevResult = state.nodeResults.get(node.input);
      if (prevResult?.status === 'success') {
        input = prevResult.output;
      }
    }

    // Get runtime type from node
    const runtimeType = getNodeRuntimeType(node);

    // Check if runtime exists
    if (!hasRuntime(runtimeType)) {
      throw new Error(`Unknown runtime type: ${runtimeType}`);
    }

    // Get runtime and execute
    const runtime = getRuntime(runtimeType);

    // Resolve config values (templates, expressions)
    const resolvedConfig = resolveNodeConfig(node.config ?? {}, state);

    // Clone state for isolation during parallel execution
    const nodeState = cloneStateForNode(state, { input });

    // Execute the runtime
    const output = await runtime.execute({
      node,
      input,
      config: resolvedConfig,
      state: nodeState,
    });

    const completedAt = Date.now();

    return {
      status: 'success',
      output,
      duration: completedAt - startedAt,
      startedAt,
      completedAt,
    };
  } catch (error) {
    const completedAt = Date.now();

    return {
      status: 'failed',
      error: error as Error,
      duration: completedAt - startedAt,
      startedAt,
      completedAt,
    };
  }
}

/**
 * Get the runtime type string from a node.
 */
function getNodeRuntimeType(node: NodeAST): string {
  switch (node.type) {
    case 'source':
      return `source:${(node as any).sourceType}`;
    case 'sink':
      return `sink:${(node as any).sinkType}`;
    case 'transform':
      return `transform:${(node as any).transformType}`;
    case 'branch':
    case 'if':
    case 'loop':
    case 'while':
    case 'foreach':
    case 'parallel':
      return `control:${node.type}`;
    case 'checkpoint':
      return 'checkpoint';
    default:
      return node.type;
  }
}

/**
 * Resolve template expressions in node config.
 */
function resolveNodeConfig(
  config: Record<string, unknown>,
  state: ExecutionState
): Record<string, unknown> {
  const resolved: Record<string, unknown> = {};

  for (const [key, value] of Object.entries(config)) {
    if (typeof value === 'string') {
      resolved[key] = resolveTemplateValue(value, state);
    } else if (typeof value === 'object' && value !== null && !Array.isArray(value)) {
      resolved[key] = resolveNodeConfig(value as Record<string, unknown>, state);
    } else {
      resolved[key] = value;
    }
  }

  return resolved;
}

/**
 * Record a node result in execution state.
 */
function recordNodeResult(
  state: ExecutionState,
  nodeId: string,
  result: NodeResult
): void {
  state.nodeResults.set(nodeId, result);

  // Also expose output in nodeContext for expression access
  if (result.status === 'success' && result.output !== undefined) {
    state.nodeContext[nodeId] = { output: result.output };
  }
}
```
  </action>
  <verify>bun build src/execution/executor.ts --no-bundle 2>&1 | head -5</verify>
  <done>Executor compiles and exports execute function</done>
</task>

<task type="auto">
  <name>Task 3: Create scheduler tests</name>
  <files>src/scheduler/scheduler.test.ts</files>
  <action>
Create comprehensive tests for the scheduler module:

```typescript
/**
 * Scheduler Module Tests
 *
 * Tests for DAG building, wave computation, semaphore, and execution plan.
 */

import { describe, test, expect } from 'bun:test';
import type { NodeAST, WorkflowAST, SourceNode } from '../types/ast';
import {
  buildExecutionPlan,
  buildDependencyGraph,
  computeWaves,
  Semaphore,
  DEFAULT_MAX_CONCURRENCY,
} from './index';

// ============================================================================
// Test Helpers
// ============================================================================

function createSourceNode(id: string, input?: string): SourceNode {
  return {
    type: 'source',
    id,
    input,
    sourceType: 'http',
    config: { url: 'https://example.com' },
    loc: { start: { line: 1, column: 0, offset: 0 }, end: { line: 1, column: 10, offset: 10 } },
  };
}

function createMinimalAST(nodes: NodeAST[]): WorkflowAST {
  return {
    metadata: { name: 'test-workflow', version: '1.0' },
    nodes,
    sourceMap: { source: '', filePath: 'test.flow.md', lineOffsets: [0] },
  };
}

// ============================================================================
// Semaphore Tests
// ============================================================================

describe('Semaphore', () => {
  test('creates with valid capacity', () => {
    const sem = new Semaphore(3);
    expect(sem.available).toBe(3);
    expect(sem.waiting).toBe(0);
  });

  test('throws for capacity < 1', () => {
    expect(() => new Semaphore(0)).toThrow('capacity must be at least 1');
    expect(() => new Semaphore(-1)).toThrow('capacity must be at least 1');
  });

  test('acquire decrements available permits', async () => {
    const sem = new Semaphore(2);
    await sem.acquire();
    expect(sem.available).toBe(1);
    await sem.acquire();
    expect(sem.available).toBe(0);
  });

  test('release increments available permits', async () => {
    const sem = new Semaphore(2);
    await sem.acquire();
    await sem.acquire();
    expect(sem.available).toBe(0);
    sem.release();
    expect(sem.available).toBe(1);
    sem.release();
    expect(sem.available).toBe(2);
  });

  test('blocks when no permits available', async () => {
    const sem = new Semaphore(1);
    const order: number[] = [];

    await sem.acquire();
    order.push(1);

    // This will block until release
    const p2 = sem.acquire().then(() => order.push(2));

    // Allow p2 to start waiting
    await new Promise((r) => setTimeout(r, 10));
    expect(sem.waiting).toBe(1);

    sem.release();
    await p2;

    expect(order).toEqual([1, 2]);
  });

  test('concurrent tasks respect limit', async () => {
    const sem = new Semaphore(2);
    let concurrent = 0;
    let maxConcurrent = 0;

    const tasks = Array.from({ length: 5 }, async (_, i) => {
      await sem.acquire();
      try {
        concurrent++;
        maxConcurrent = Math.max(maxConcurrent, concurrent);
        await new Promise((r) => setTimeout(r, 20));
        concurrent--;
      } finally {
        sem.release();
      }
      return i;
    });

    await Promise.all(tasks);

    expect(maxConcurrent).toBe(2);
  });
});

// ============================================================================
// DAG Builder Tests
// ============================================================================

describe('buildDependencyGraph', () => {
  test('returns empty deps for nodes without input', () => {
    const nodes = [createSourceNode('a'), createSourceNode('b')];
    const graph = buildDependencyGraph(nodes);

    expect(graph.get('a')?.size).toBe(0);
    expect(graph.get('b')?.size).toBe(0);
  });

  test('records input as dependency', () => {
    const nodes = [
      createSourceNode('a'),
      createSourceNode('b', 'a'),
    ];
    const graph = buildDependencyGraph(nodes);

    expect(graph.get('a')?.size).toBe(0);
    expect(graph.get('b')?.has('a')).toBe(true);
  });

  test('handles chain of dependencies', () => {
    const nodes = [
      createSourceNode('a'),
      createSourceNode('b', 'a'),
      createSourceNode('c', 'b'),
    ];
    const graph = buildDependencyGraph(nodes);

    expect(graph.get('a')?.size).toBe(0);
    expect(graph.get('b')?.has('a')).toBe(true);
    expect(graph.get('c')?.has('b')).toBe(true);
  });
});

// ============================================================================
// Wave Computation Tests
// ============================================================================

describe('computeWaves', () => {
  test('single node is wave 0', () => {
    const nodes = [createSourceNode('a')];
    const deps = buildDependencyGraph(nodes);
    const waves = computeWaves(nodes, deps);

    expect(waves.length).toBe(1);
    expect(waves[0].waveNumber).toBe(0);
    expect(waves[0].nodeIds).toEqual(['a']);
  });

  test('independent nodes are same wave', () => {
    const nodes = [
      createSourceNode('a'),
      createSourceNode('b'),
      createSourceNode('c'),
    ];
    const deps = buildDependencyGraph(nodes);
    const waves = computeWaves(nodes, deps);

    expect(waves.length).toBe(1);
    expect(waves[0].nodeIds).toContain('a');
    expect(waves[0].nodeIds).toContain('b');
    expect(waves[0].nodeIds).toContain('c');
  });

  test('dependent node is next wave', () => {
    const nodes = [
      createSourceNode('a'),
      createSourceNode('b', 'a'),
    ];
    const deps = buildDependencyGraph(nodes);
    const waves = computeWaves(nodes, deps);

    expect(waves.length).toBe(2);
    expect(waves[0].nodeIds).toEqual(['a']);
    expect(waves[1].nodeIds).toEqual(['b']);
  });

  test('chain creates sequential waves', () => {
    const nodes = [
      createSourceNode('a'),
      createSourceNode('b', 'a'),
      createSourceNode('c', 'b'),
    ];
    const deps = buildDependencyGraph(nodes);
    const waves = computeWaves(nodes, deps);

    expect(waves.length).toBe(3);
    expect(waves[0].nodeIds).toEqual(['a']);
    expect(waves[1].nodeIds).toEqual(['b']);
    expect(waves[2].nodeIds).toEqual(['c']);
  });

  test('diamond pattern creates correct waves', () => {
    // a -> b, a -> c, b -> d, c -> d
    const nodes: NodeAST[] = [
      createSourceNode('a'),
      createSourceNode('b', 'a'),
      createSourceNode('c', 'a'),
      createSourceNode('d', 'b'), // d also implicitly depends on c for full diamond
    ];
    // Add c dependency to d manually for full diamond
    nodes[3].input = 'b'; // Note: single input limitation

    const deps = buildDependencyGraph(nodes);
    const waves = computeWaves(nodes, deps);

    // Wave 0: a
    // Wave 1: b, c
    // Wave 2: d
    expect(waves.length).toBe(3);
    expect(waves[0].nodeIds).toEqual(['a']);
    expect(waves[1].nodeIds.sort()).toEqual(['b', 'c']);
  });
});

// ============================================================================
// Execution Plan Tests
// ============================================================================

describe('buildExecutionPlan', () => {
  test('creates plan for empty workflow', () => {
    const ast = createMinimalAST([]);
    const plan = buildExecutionPlan(ast);

    expect(plan.workflowId).toBe('test-workflow');
    expect(plan.totalNodes).toBe(0);
    expect(plan.waves.length).toBe(0);
  });

  test('creates plan with node lookup', () => {
    const nodes = [createSourceNode('fetch'), createSourceNode('process', 'fetch')];
    const ast = createMinimalAST(nodes);
    const plan = buildExecutionPlan(ast);

    expect(plan.totalNodes).toBe(2);
    expect(plan.nodes.get('fetch')).toBeDefined();
    expect(plan.nodes.get('process')).toBeDefined();
  });

  test('computes waves correctly', () => {
    const nodes = [
      createSourceNode('a'),
      createSourceNode('b'),
      createSourceNode('c', 'a'),
      createSourceNode('d', 'b'),
    ];
    const ast = createMinimalAST(nodes);
    const plan = buildExecutionPlan(ast);

    expect(plan.waves.length).toBe(2);
    expect(plan.waves[0].nodeIds.sort()).toEqual(['a', 'b']);
    expect(plan.waves[1].nodeIds.sort()).toEqual(['c', 'd']);
  });
});

// ============================================================================
// Constants Tests
// ============================================================================

describe('Constants', () => {
  test('DEFAULT_MAX_CONCURRENCY is 10', () => {
    expect(DEFAULT_MAX_CONCURRENCY).toBe(10);
  });
});
```
  </action>
  <verify>bun test src/scheduler/scheduler.test.ts</verify>
  <done>All scheduler tests pass</done>
</task>

</tasks>

<verification>
```bash
# Run scheduler tests
bun test src/scheduler/scheduler.test.ts

# Verify executor compiles
bun build src/execution/executor.ts --no-bundle

# Verify imports work
bun -e "import { execute } from './src/execution/executor'; console.log('Executor OK')"
```
</verification>

<success_criteria>
- [ ] cloneStateForNode added to state.ts for parallel isolation
- [ ] executor.ts implements execute() and executeWave()
- [ ] Executor uses Semaphore for concurrency limiting
- [ ] Node results recorded after execution
- [ ] Fail-fast error handling in wave execution
- [ ] Scheduler tests pass (Semaphore, DAG, waves, plan)
- [ ] All files compile without TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/06-scheduling-parallelism/06-02-SUMMARY.md`
</output>
