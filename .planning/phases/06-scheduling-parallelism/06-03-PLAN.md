---
phase: 06-scheduling-parallelism
plan: 03
type: execute
wave: 3
depends_on: [06-02]
# Note: 06-02 re-exports Semaphore via scheduler/index.ts, so we don't need direct 06-01 dependency
files_modified:
  - src/runtimes/control/parallel.ts
  - src/runtimes/control/types.ts
  - src/runtimes/control/index.ts
  - src/execution/executor.ts
autonomous: true

must_haves:
  truths:
    - Parallel runtime returns branch metadata (branches array, count)
    - Executor detects parallel result and executes branches concurrently
    - Each parallel branch gets isolated state via structuredClone
    - All branch results collected and available after parallel completes
    - Concurrency limit respected across parallel branches
    - Branch errors collected and surfaced (fail-fast within parallel)
  artifacts:
    - src/runtimes/control/parallel.ts (ParallelRuntime, ParallelResult)
    - src/runtimes/control/types.ts (ParallelConfig added)
    - src/execution/executor.ts (handleParallelResult function)
  key_links:
    - parallel.ts registered via control/index.ts side-effect import
    - executor.ts checks for ParallelResult and calls handleParallelResult
    - ParallelResult.branches are NodeAST[][] (array of branch node arrays)
    - handleParallelResult uses nodes map from executeNode parameters
    - Semaphore imported from scheduler/index.ts (via 06-02 setup)
---

<objective>
Implement the parallel block runtime and integrate it with the executor for concurrent branch execution.

Purpose: Enables explicit parallelism in workflows via `<parallel>` blocks where independent branches execute simultaneously.

Output: Working parallel runtime and executor integration that runs branches concurrently with state isolation.
</objective>

<execution_context>
@/Users/narcisbrindusescu/.claude/looppool/workflows/execute-plan.md
@/Users/narcisbrindusescu/.claude/looppool/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-scheduling-parallelism/06-RESEARCH.md

# Dependencies - executor from 06-02 (which re-exports scheduler utilities)
@src/scheduler/types.ts
@src/scheduler/concurrency.ts
@src/execution/executor.ts

# Existing control flow patterns
@src/runtimes/control/foreach.ts
@src/runtimes/control/types.ts
@src/runtimes/control/index.ts
@src/types/ast.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add ParallelConfig to control types</name>
  <files>src/runtimes/control/types.ts</files>
  <action>
Read the existing types.ts file and add ParallelConfig type:

```typescript
/**
 * Configuration for parallel blocks.
 */
export interface ParallelConfig {
  /** Maximum concurrent branches (default: all branches) */
  maxConcurrency?: number;
}
```

Add this alongside the existing config types (BranchConfig, IfConfig, etc.)
  </action>
  <verify>bun build src/runtimes/control/types.ts --no-bundle 2>&1 | head -5</verify>
  <done>ParallelConfig type added and compiles</done>
</task>

<task type="auto">
  <name>Task 2: Implement parallel runtime</name>
  <files>src/runtimes/control/parallel.ts</files>
  <action>
Create the parallel runtime following the control flow pattern:

```typescript
/**
 * Parallel Runtime for FlowScript
 *
 * Executes multiple branches concurrently.
 * Returns metadata for executor to handle actual parallel execution.
 */

import type { NodeRuntime, ExecutionParams } from '../types';
import type { ParallelConfig } from './types';
import type { ParallelNode, NodeAST } from '../../types/ast';

// ============================================================================
// Parallel Result Types
// ============================================================================

/**
 * Result returned by parallel runtime with branch metadata.
 * The executor detects this type and handles branch execution.
 */
export interface ParallelResult {
  /** Branches to execute in parallel (each branch is an array of NodeAST) */
  branches: NodeAST[][];
  /** Number of branches */
  branchCount: number;
  /** Maximum concurrent branches (undefined = unlimited) */
  maxConcurrency?: number;
}

// ============================================================================
// Parallel Runtime Implementation
// ============================================================================

/**
 * Parallel Runtime - returns branch metadata for executor to handle.
 *
 * The parallel runtime itself doesn't execute branches.
 * It extracts the branch structure and returns metadata.
 * The executor then runs branches concurrently with state isolation.
 *
 * @example
 * ```xml
 * <parallel id="fetch-all">
 *   <branch>
 *     <source:http id="api1" url="https://api1.example.com" />
 *   </branch>
 *   <branch>
 *     <source:http id="api2" url="https://api2.example.com" />
 *   </branch>
 *   <branch>
 *     <source:http id="api3" url="https://api3.example.com" />
 *   </branch>
 * </parallel>
 * ```
 */
class ParallelRuntime implements NodeRuntime<ParallelConfig, unknown, ParallelResult> {
  readonly type = 'control:parallel';

  async execute(params: ExecutionParams<ParallelConfig, unknown>): Promise<ParallelResult> {
    const { node, config } = params;

    // Cast to ParallelNode to access branches
    const parallelNode = node as unknown as ParallelNode;

    // Get maxConcurrency from config (optional)
    const maxConcurrency = config.maxConcurrency;

    return {
      branches: parallelNode.branches,
      branchCount: parallelNode.branches.length,
      maxConcurrency,
    };
  }
}

/**
 * Parallel runtime instance.
 */
export const parallelRuntime = new ParallelRuntime();
```
  </action>
  <verify>bun build src/runtimes/control/parallel.ts --no-bundle 2>&1 | head -5</verify>
  <done>Parallel runtime compiles and exports parallelRuntime instance</done>
</task>

<task type="auto">
  <name>Task 3: Register parallel runtime and update executor</name>
  <files>src/runtimes/control/index.ts, src/execution/executor.ts</files>
  <action>
First, update src/runtimes/control/index.ts to import and register parallel runtime.
Read the existing file and add:

```typescript
// Add import
import { parallelRuntime, type ParallelResult } from './parallel';

// Add registration in the registration block
registry.register('control:parallel', parallelRuntime);

// Add to exports
export { parallelRuntime, type ParallelResult } from './parallel';
export type { ParallelConfig } from './types';
```

Then, update src/execution/executor.ts to handle ParallelResult.
Read the existing file (modified in 06-02) and add:

1. Import ParallelResult:
```typescript
import type { ParallelResult } from '../runtimes/control/parallel';
```

2. Add a helper to check if result is ParallelResult:
```typescript
/**
 * Check if a node result output is a ParallelResult.
 */
function isParallelResult(output: unknown): output is ParallelResult {
  return (
    typeof output === 'object' &&
    output !== null &&
    'branches' in output &&
    Array.isArray((output as ParallelResult).branches) &&
    'branchCount' in output
  );
}
```

3. Add handleParallelResult function that uses the nodes map parameter:
```typescript
/**
 * Execute parallel branches concurrently.
 *
 * Each branch gets an isolated state clone.
 * Results from all branches are collected.
 *
 * Note: Branch nodes are executed via executeNode, which has access to the
 * nodes map for nested control flow. Branch nodes are regular nodes, not
 * control flow nodes themselves (unless explicitly nested), so there's no
 * recursion risk.
 */
async function handleParallelResult(
  result: ParallelResult,
  nodes: Map<string, NodeAST>,
  state: ExecutionState,
  maxConcurrency: number
): Promise<unknown[]> {
  const { branches, maxConcurrency: branchLimit } = result;

  // Use branch-specific limit if provided, otherwise global limit
  const concurrency = branchLimit ?? maxConcurrency;
  const semaphore = new Semaphore(concurrency);
  const branchResults: unknown[] = new Array(branches.length);
  const errors: Error[] = [];

  const branchExecutions = branches.map(async (branchNodes, branchIndex) => {
    await semaphore.acquire();
    try {
      // Deep clone state for branch isolation
      const branchState = cloneStateForBranch(state, branchIndex);

      // Execute all nodes in this branch sequentially
      let lastOutput: unknown = undefined;
      for (const node of branchNodes) {
        // Execute node with nodes map for potential nested control flow
        const nodeResult = await executeNode(node, nodes, branchState, maxConcurrency);
        recordNodeResult(branchState, node.id, nodeResult);

        if (nodeResult.status === 'failed') {
          throw nodeResult.error ?? new Error(`Node ${node.id} failed`);
        }

        lastOutput = nodeResult.output;

        // Copy results back to main state
        state.nodeResults.set(node.id, nodeResult);
        if (nodeResult.output !== undefined) {
          state.nodeContext[node.id] = { output: nodeResult.output };
        }
      }

      branchResults[branchIndex] = lastOutput;
    } catch (error) {
      errors.push(error as Error);
    } finally {
      semaphore.release();
    }
  });

  await Promise.all(branchExecutions);

  // Fail-fast: surface first error
  if (errors.length > 0) {
    throw errors[0];
  }

  return branchResults;
}

/**
 * Clone state for parallel branch execution.
 */
function cloneStateForBranch(
  state: ExecutionState,
  branchIndex: number
): ExecutionState {
  return {
    ...state,
    nodeContext: {
      ...structuredClone(state.nodeContext),
      $branch: branchIndex,
    },
    phaseContext: { ...state.phaseContext },
    globalContext: { ...state.globalContext },
    nodeResults: state.nodeResults, // Shared - writes isolated by nodeId
    config: state.config,
    secrets: state.secrets,
  };
}
```

4. Modify executeNode to call handleParallelResult when output is ParallelResult:
In the success path of executeNode, after getting output from runtime.execute():

```typescript
// Check if this is a parallel result that needs branch execution
if (isParallelResult(output)) {
  // Execute branches using the nodes map passed to executeNode
  const branchOutputs = await handleParallelResult(
    output,
    nodes,  // nodes map is available from executeNode parameters
    state,
    maxConcurrency
  );
  output = branchOutputs;
}
```

**Key point:** The nodes map is already available in executeNode from 06-02. The
handleParallelResult function uses this to execute branch nodes. Branch nodes
are regular nodes (source, transform, sink), not control flow nodes that would
return another ParallelResult, so there's no infinite recursion risk.
  </action>
  <verify>bun build src/execution/executor.ts --no-bundle 2>&1 | head -5</verify>
  <done>Parallel runtime registered and executor handles ParallelResult</done>
</task>

</tasks>

<verification>
```bash
# Verify parallel runtime compiles
bun build src/runtimes/control/parallel.ts --no-bundle

# Verify registration
bun -e "import { hasRuntime } from './src/runtimes/registry'; console.log('control:parallel:', hasRuntime('control:parallel'))"

# Verify executor compiles
bun build src/execution/executor.ts --no-bundle

# Run existing tests to ensure no regressions
bun test src/runtimes/control/control.test.ts
```
</verification>

<success_criteria>
- [ ] ParallelConfig added to control/types.ts
- [ ] parallel.ts implements ParallelRuntime returning ParallelResult
- [ ] Parallel runtime registered as 'control:parallel'
- [ ] Executor detects ParallelResult and executes branches
- [ ] handleParallelResult uses nodes map from executeNode parameters
- [ ] Branch execution uses cloneStateForBranch for isolation
- [ ] Semaphore respects maxConcurrency during branch execution
- [ ] Errors from branches are collected and surfaced
- [ ] All files compile without TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/06-scheduling-parallelism/06-03-SUMMARY.md`
</output>
