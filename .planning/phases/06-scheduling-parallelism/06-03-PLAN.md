---
phase: 06-scheduling-parallelism
plan: 03
type: execute
wave: 3
depends_on: [06-02]
files_modified:
  - src/runtimes/control/parallel.ts
  - src/runtimes/control/types.ts
  - src/runtimes/control/index.ts
  - src/execution/executor.ts
autonomous: true

must_haves:
  truths:
    - Parallel runtime returns branch metadata (branches array, count)
    - Executor detects parallel result and executes branches concurrently
    - Each parallel branch gets isolated state via structuredClone
    - All branch results collected and available after parallel completes
    - Concurrency limit respected across parallel branches
    - Branch errors collected and surfaced (fail-fast within parallel)
  artifacts:
    - src/runtimes/control/parallel.ts (ParallelRuntime, ParallelResult)
    - src/runtimes/control/types.ts (ParallelConfig added)
    - src/execution/executor.ts (handleParallelResult function)
  key_links:
    - parallel.ts registered via control/index.ts side-effect import
    - executor.ts checks for ParallelResult and calls handleParallelResult
    - ParallelResult.branches are NodeAST[][] executed concurrently
---

<objective>
Implement the parallel block runtime and integrate it with the executor for concurrent branch execution.

Purpose: Enables explicit parallelism in workflows via `<parallel>` blocks where independent branches execute simultaneously.

Output: Working parallel runtime and executor integration that runs branches concurrently with state isolation.
</objective>

<execution_context>
@/Users/narcisbrindusescu/.claude/looppool/workflows/execute-plan.md
@/Users/narcisbrindusescu/.claude/looppool/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-scheduling-parallelism/06-RESEARCH.md

# Dependencies
@src/scheduler/types.ts
@src/scheduler/concurrency.ts
@src/execution/executor.ts

# Existing control flow patterns
@src/runtimes/control/foreach.ts
@src/runtimes/control/types.ts
@src/runtimes/control/index.ts
@src/types/ast.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add ParallelConfig to control types</name>
  <files>src/runtimes/control/types.ts</files>
  <action>
Read the existing types.ts file and add ParallelConfig type:

```typescript
/**
 * Configuration for parallel blocks.
 */
export interface ParallelConfig {
  /** Maximum concurrent branches (default: all branches) */
  maxConcurrency?: number;
}
```

Add this alongside the existing config types (BranchConfig, IfConfig, etc.)
  </action>
  <verify>bun build src/runtimes/control/types.ts --no-bundle 2>&1 | head -5</verify>
  <done>ParallelConfig type added and compiles</done>
</task>

<task type="auto">
  <name>Task 2: Implement parallel runtime</name>
  <files>src/runtimes/control/parallel.ts</files>
  <action>
Create the parallel runtime following the control flow pattern:

```typescript
/**
 * Parallel Runtime for FlowScript
 *
 * Executes multiple branches concurrently.
 * Returns metadata for executor to handle actual parallel execution.
 */

import type { NodeRuntime, ExecutionParams } from '../types';
import type { ParallelConfig } from './types';
import type { ParallelNode, NodeAST } from '../../types/ast';

// ============================================================================
// Parallel Result Types
// ============================================================================

/**
 * Result returned by parallel runtime with branch metadata.
 */
export interface ParallelResult {
  /** Branches to execute in parallel (each branch is an array of nodes) */
  branches: NodeAST[][];
  /** Number of branches */
  branchCount: number;
  /** Maximum concurrent branches (undefined = unlimited) */
  maxConcurrency?: number;
}

// ============================================================================
// Parallel Runtime Implementation
// ============================================================================

/**
 * Parallel Runtime - returns branch metadata for executor to handle.
 *
 * The parallel runtime itself doesn't execute branches.
 * It extracts the branch structure and returns metadata.
 * The executor then runs branches concurrently with state isolation.
 *
 * @example
 * ```xml
 * <parallel id="fetch-all">
 *   <branch>
 *     <source:http id="api1" url="https://api1.example.com" />
 *   </branch>
 *   <branch>
 *     <source:http id="api2" url="https://api2.example.com" />
 *   </branch>
 *   <branch>
 *     <source:http id="api3" url="https://api3.example.com" />
 *   </branch>
 * </parallel>
 * ```
 */
class ParallelRuntime implements NodeRuntime<ParallelConfig, unknown, ParallelResult> {
  readonly type = 'control:parallel';

  async execute(params: ExecutionParams<ParallelConfig, unknown>): Promise<ParallelResult> {
    const { node, config } = params;

    // Cast to ParallelNode to access branches
    const parallelNode = node as unknown as ParallelNode;

    // Get maxConcurrency from config (optional)
    const maxConcurrency = config.maxConcurrency;

    return {
      branches: parallelNode.branches,
      branchCount: parallelNode.branches.length,
      maxConcurrency,
    };
  }
}

/**
 * Parallel runtime instance.
 */
export const parallelRuntime = new ParallelRuntime();
```
  </action>
  <verify>bun build src/runtimes/control/parallel.ts --no-bundle 2>&1 | head -5</verify>
  <done>Parallel runtime compiles and exports parallelRuntime instance</done>
</task>

<task type="auto">
  <name>Task 3: Register parallel runtime and update executor</name>
  <files>src/runtimes/control/index.ts, src/execution/executor.ts</files>
  <action>
First, update src/runtimes/control/index.ts to import and register parallel runtime.
Read the existing file and add:

```typescript
// Add import
import { parallelRuntime, type ParallelResult } from './parallel';

// Add registration in the registration block
registry.register('control:parallel', parallelRuntime);

// Add to exports
export { parallelRuntime, type ParallelResult } from './parallel';
export type { ParallelConfig } from './types';
```

Then, update src/execution/executor.ts to handle ParallelResult.
Read the existing file and add:

1. Import ParallelResult:
```typescript
import type { ParallelResult } from '../runtimes/control/parallel';
```

2. Add a helper to check if result is ParallelResult:
```typescript
/**
 * Check if a node result output is a ParallelResult.
 */
function isParallelResult(output: unknown): output is ParallelResult {
  return (
    typeof output === 'object' &&
    output !== null &&
    'branches' in output &&
    Array.isArray((output as ParallelResult).branches) &&
    'branchCount' in output
  );
}
```

3. Add handleParallelResult function:
```typescript
/**
 * Execute parallel branches concurrently.
 *
 * Each branch gets an isolated state clone.
 * Results from all branches are collected.
 */
async function handleParallelResult(
  result: ParallelResult,
  state: ExecutionState,
  maxConcurrency: number
): Promise<unknown[]> {
  const { branches, maxConcurrency: branchLimit } = result;

  // Use branch-specific limit if provided, otherwise global limit
  const concurrency = branchLimit ?? maxConcurrency;
  const semaphore = new Semaphore(concurrency);
  const branchResults: unknown[] = new Array(branches.length);
  const errors: Error[] = [];

  const branchExecutions = branches.map(async (branchNodes, branchIndex) => {
    await semaphore.acquire();
    try {
      // Deep clone state for branch isolation
      const branchState = cloneStateForBranch(state, branchIndex);

      // Execute all nodes in this branch sequentially
      let lastOutput: unknown = undefined;
      for (const node of branchNodes) {
        const nodeResult = await executeNode(node, branchState);
        recordNodeResult(branchState, node.id, nodeResult);

        if (nodeResult.status === 'failed') {
          throw nodeResult.error ?? new Error(`Node ${node.id} failed`);
        }

        lastOutput = nodeResult.output;

        // Copy results back to main state
        state.nodeResults.set(node.id, nodeResult);
        if (nodeResult.output !== undefined) {
          state.nodeContext[node.id] = { output: nodeResult.output };
        }
      }

      branchResults[branchIndex] = lastOutput;
    } catch (error) {
      errors.push(error as Error);
    } finally {
      semaphore.release();
    }
  });

  await Promise.all(branchExecutions);

  // Fail-fast: surface first error
  if (errors.length > 0) {
    throw errors[0];
  }

  return branchResults;
}

/**
 * Clone state for parallel branch execution.
 */
function cloneStateForBranch(
  state: ExecutionState,
  branchIndex: number
): ExecutionState {
  return {
    ...state,
    nodeContext: {
      ...structuredClone(state.nodeContext),
      $branch: branchIndex,
    },
    phaseContext: { ...state.phaseContext },
    globalContext: { ...state.globalContext },
    nodeResults: state.nodeResults, // Shared - writes isolated by nodeId
    config: state.config,
    secrets: state.secrets,
  };
}
```

4. Modify executeNode to call handleParallelResult when output is ParallelResult:
In the success path of executeNode, after getting output:

```typescript
// Check if this is a parallel result that needs branch execution
if (isParallelResult(output)) {
  // Execute branches and use array of results as output
  const branchOutputs = await handleParallelResult(
    output,
    state,
    DEFAULT_MAX_CONCURRENCY // or pass through options
  );
  output = branchOutputs;
}
```

Note: This requires restructuring executeNode slightly to handle the parallel case.
The key change is that parallel nodes return ParallelResult from the runtime,
and the executor detects this and runs branches before recording the final result.
  </action>
  <verify>bun build src/execution/executor.ts --no-bundle 2>&1 | head -5</verify>
  <done>Parallel runtime registered and executor handles ParallelResult</done>
</task>

</tasks>

<verification>
```bash
# Verify parallel runtime compiles
bun build src/runtimes/control/parallel.ts --no-bundle

# Verify registration
bun -e "import { hasRuntime } from './src/runtimes/registry'; console.log('control:parallel:', hasRuntime('control:parallel'))"

# Verify executor compiles
bun build src/execution/executor.ts --no-bundle

# Run existing tests to ensure no regressions
bun test src/runtimes/control/control.test.ts
```
</verification>

<success_criteria>
- [ ] ParallelConfig added to control/types.ts
- [ ] parallel.ts implements ParallelRuntime returning ParallelResult
- [ ] Parallel runtime registered as 'control:parallel'
- [ ] Executor detects ParallelResult and executes branches
- [ ] Branch execution uses cloneStateForBranch for isolation
- [ ] Semaphore respects maxConcurrency during branch execution
- [ ] Errors from branches are collected and surfaced
- [ ] All files compile without TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/06-scheduling-parallelism/06-03-SUMMARY.md`
</output>
