---
phase: 06-scheduling-parallelism
plan: 04
type: execute
wave: 4
depends_on: [06-03]
files_modified:
  - src/execution/executor.ts
  - src/execution/index.ts
  - src/execution/executor.test.ts
autonomous: true

must_haves:
  truths:
    - Foreach with maxConcurrency > 1 runs iterations in parallel
    - Iteration results maintain index order regardless of completion order
    - Each iteration gets isolated state with $item, $index variables
    - Break in parallel foreach only stops its own iteration
    - Executor exports are available from execution/index.ts
    - Full integration tests validate wave execution with real runtimes
  artifacts:
    - src/execution/executor.ts (handleForeachResult enhanced)
    - src/execution/index.ts (executor exports added)
    - src/execution/executor.test.ts (integration tests)
  key_links:
    - executor.ts checks ForeachResult.maxConcurrency to decide parallel vs sequential
    - executor.ts iteration uses semaphore when maxConcurrency > 1
    - execution/index.ts re-exports execute from executor.ts
---

<objective>
Complete parallel execution by adding foreach parallel iteration support and comprehensive integration tests.

Purpose: Enables parallel foreach iterations and validates the complete scheduling/execution pipeline works correctly.

Output: Full parallel execution capability with tested foreach parallelism and workflow execution integration.
</objective>

<execution_context>
@/Users/narcisbrindusescu/.claude/looppool/workflows/execute-plan.md
@/Users/narcisbrindusescu/.claude/looppool/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-scheduling-parallelism/06-RESEARCH.md

# Dependencies
@src/scheduler/types.ts
@src/scheduler/concurrency.ts
@src/execution/executor.ts
@src/runtimes/control/foreach.ts

# Existing patterns
@src/execution/types.ts
@src/execution/state.ts
@src/execution/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add foreach parallel iteration to executor</name>
  <files>src/execution/executor.ts</files>
  <action>
Read the existing executor.ts and add support for parallel foreach iterations.

1. Import ForeachResult:
```typescript
import type { ForeachResult } from '../runtimes/control/foreach';
```

2. Add helper to check for ForeachResult:
```typescript
/**
 * Check if a node result output is a ForeachResult.
 */
function isForeachResult(output: unknown): output is ForeachResult {
  return (
    typeof output === 'object' &&
    output !== null &&
    'collection' in output &&
    Array.isArray((output as ForeachResult).collection) &&
    'itemVar' in output &&
    'bodyNodeIds' in output
  );
}
```

3. Add handleForeachResult function:
```typescript
/**
 * Execute foreach iterations, potentially in parallel.
 *
 * When maxConcurrency is 1 (default), executes sequentially.
 * When maxConcurrency > 1, executes iterations in parallel up to the limit.
 *
 * Results maintain index order regardless of completion order.
 *
 * Note: Break in parallel mode only stops its own iteration,
 * not other parallel iterations. Use maxConcurrency: 1 for break-all.
 */
async function handleForeachResult(
  result: ForeachResult,
  state: ExecutionState,
  nodes: Map<string, NodeAST>,
  maxGlobalConcurrency: number
): Promise<unknown[]> {
  const { collection, itemVar, indexVar, maxConcurrency, bodyNodeIds } = result;

  // Get body nodes
  const bodyNodes = bodyNodeIds.map((id) => nodes.get(id)).filter(Boolean) as NodeAST[];

  // Results array maintains index order
  const results: unknown[] = new Array(collection.length);
  const errors: Error[] = [];

  if (maxConcurrency === 1) {
    // Sequential execution (original behavior)
    for (let i = 0; i < collection.length; i++) {
      try {
        const iterState = cloneStateForIteration(state, {
          [itemVar]: collection[i],
          [indexVar]: i,
        });

        let lastOutput: unknown = undefined;
        for (const node of bodyNodes) {
          const nodeResult = await executeNode(node, iterState);
          recordNodeResult(iterState, node.id, nodeResult);

          if (nodeResult.status === 'failed') {
            throw nodeResult.error ?? new Error(`Node ${node.id} failed`);
          }

          lastOutput = nodeResult.output;
        }

        results[i] = lastOutput;
      } catch (error) {
        if (isBreakSignal(error)) {
          // Break stops sequential iteration
          break;
        }
        throw error;
      }
    }
  } else {
    // Parallel execution
    const semaphore = new Semaphore(maxConcurrency);

    const iterations = collection.map(async (item, index) => {
      await semaphore.acquire();
      try {
        const iterState = cloneStateForIteration(state, {
          [itemVar]: item,
          [indexVar]: index,
        });

        let lastOutput: unknown = undefined;
        for (const node of bodyNodes) {
          const nodeResult = await executeNode(node, iterState);
          recordNodeResult(iterState, node.id, nodeResult);

          if (nodeResult.status === 'failed') {
            throw nodeResult.error ?? new Error(`Node ${node.id} failed`);
          }

          lastOutput = nodeResult.output;
        }

        // Assign by index to maintain order
        results[index] = lastOutput;
      } catch (error) {
        if (isBreakSignal(error)) {
          // Break in parallel only stops this iteration
          // Other iterations continue
          return;
        }
        errors.push(error as Error);
      } finally {
        semaphore.release();
      }
    });

    await Promise.all(iterations);

    // Fail-fast: surface first error
    if (errors.length > 0) {
      throw errors[0];
    }
  }

  return results;
}

/**
 * Clone state for foreach iteration.
 */
function cloneStateForIteration(
  state: ExecutionState,
  iterationContext: Record<string, unknown>
): ExecutionState {
  return {
    ...state,
    nodeContext: {
      ...structuredClone(state.nodeContext),
      ...iterationContext,
    },
    phaseContext: { ...state.phaseContext },
    globalContext: { ...state.globalContext },
    nodeResults: state.nodeResults, // Shared
    config: state.config,
    secrets: state.secrets,
  };
}

/**
 * Check if error is a BreakSignal.
 */
function isBreakSignal(error: unknown): boolean {
  return (
    typeof error === 'object' &&
    error !== null &&
    'name' in error &&
    (error as { name: string }).name === 'BreakSignal'
  );
}
```

4. Update executeNode to detect ForeachResult and call handleForeachResult:
After the ParallelResult check, add:

```typescript
// Check if this is a foreach result that needs iteration execution
if (isForeachResult(output)) {
  const foreachOutputs = await handleForeachResult(
    output,
    state,
    plan.nodes, // Need access to nodes map
    maxConcurrency
  );
  output = foreachOutputs;
}
```

Note: The executor may need to be restructured to pass the nodes map through,
or the foreach handler can look up nodes differently.
  </action>
  <verify>bun build src/execution/executor.ts --no-bundle 2>&1 | head -5</verify>
  <done>Foreach parallel iteration works with maxConcurrency > 1</done>
</task>

<task type="auto">
  <name>Task 2: Update execution index exports</name>
  <files>src/execution/index.ts</files>
  <action>
Read the existing execution/index.ts and add executor exports:

```typescript
// Add executor exports
export { execute } from './executor';
```

This makes the execute function available from the main execution module.
  </action>
  <verify>bun -e "import { execute } from './src/execution'; console.log('execute:', typeof execute)"</verify>
  <done>execute function exported from execution/index.ts</done>
</task>

<task type="auto">
  <name>Task 3: Create comprehensive integration tests</name>
  <files>src/execution/executor.test.ts</files>
  <action>
Create integration tests for the executor:

```typescript
/**
 * Executor Integration Tests
 *
 * Tests for wave execution, parallel blocks, and foreach parallelism.
 */

import { describe, test, expect, mock } from 'bun:test';
import type { WorkflowAST, SourceNode, TransformNode, ParallelNode, ForeachNode } from '../types/ast';
import { buildExecutionPlan } from '../scheduler';
import { execute } from './executor';
import { createExecutionState } from './state';

// Import runtimes to trigger registration
import '../runtimes';

// ============================================================================
// Test Helpers
// ============================================================================

function createSourceNode(id: string, input?: string): SourceNode {
  return {
    type: 'source',
    id,
    input,
    sourceType: 'http',
    config: { url: 'https://example.com', method: 'GET' },
    loc: { start: { line: 1, column: 0, offset: 0 }, end: { line: 1, column: 10, offset: 10 } },
  };
}

function createTransformNode(id: string, input: string, template: string): TransformNode {
  return {
    type: 'transform',
    id,
    input,
    transformType: 'template',
    config: { template },
    loc: { start: { line: 1, column: 0, offset: 0 }, end: { line: 1, column: 10, offset: 10 } },
  };
}

function createMapNode(id: string, input: string, expression: string): TransformNode {
  return {
    type: 'transform',
    id,
    input,
    transformType: 'map',
    config: { expression },
    loc: { start: { line: 1, column: 0, offset: 0 }, end: { line: 1, column: 10, offset: 10 } },
  };
}

function createAST(nodes: any[]): WorkflowAST {
  return {
    metadata: { name: 'test-workflow', version: '1.0' },
    nodes,
    sourceMap: { source: '', filePath: 'test.flow.md', lineOffsets: [0] },
  };
}

// ============================================================================
// Wave Execution Tests
// ============================================================================

describe('Wave Execution', () => {
  test('executes single wave', async () => {
    // Two independent template nodes
    const ast = createAST([
      {
        type: 'transform',
        id: 'a',
        transformType: 'template',
        config: { template: 'Hello A' },
        loc: { start: { line: 1, column: 0, offset: 0 }, end: { line: 1, column: 10, offset: 10 } },
      },
      {
        type: 'transform',
        id: 'b',
        transformType: 'template',
        config: { template: 'Hello B' },
        loc: { start: { line: 1, column: 0, offset: 0 }, end: { line: 1, column: 10, offset: 10 } },
      },
    ]);

    const plan = buildExecutionPlan(ast);
    const state = createExecutionState({ workflowId: 'test' });

    await execute(plan, state);

    expect(state.status).toBe('completed');
    expect(state.nodeResults.get('a')?.status).toBe('success');
    expect(state.nodeResults.get('b')?.status).toBe('success');
    expect(state.nodeResults.get('a')?.output).toBe('Hello A');
    expect(state.nodeResults.get('b')?.output).toBe('Hello B');
  });

  test('executes sequential waves', async () => {
    // a -> b chain
    const ast = createAST([
      {
        type: 'transform',
        id: 'a',
        transformType: 'template',
        config: { template: 'First' },
        loc: { start: { line: 1, column: 0, offset: 0 }, end: { line: 1, column: 10, offset: 10 } },
      },
      {
        type: 'transform',
        id: 'b',
        input: 'a',
        transformType: 'template',
        config: { template: 'Got: {{input}}' },
        loc: { start: { line: 1, column: 0, offset: 0 }, end: { line: 1, column: 10, offset: 10 } },
      },
    ]);

    const plan = buildExecutionPlan(ast);
    expect(plan.waves.length).toBe(2);

    const state = createExecutionState({ workflowId: 'test' });
    await execute(plan, state);

    expect(state.status).toBe('completed');
    expect(state.nodeResults.get('a')?.output).toBe('First');
    expect(state.nodeResults.get('b')?.output).toBe('Got: First');
  });

  test('respects concurrency limit', async () => {
    // 5 independent nodes with maxConcurrency: 2
    const nodes = Array.from({ length: 5 }, (_, i) => ({
      type: 'transform' as const,
      id: `node-${i}`,
      transformType: 'template' as const,
      config: { template: `Node ${i}` },
      loc: { start: { line: 1, column: 0, offset: 0 }, end: { line: 1, column: 10, offset: 10 } },
    }));

    const ast = createAST(nodes);
    const plan = buildExecutionPlan(ast);
    expect(plan.waves.length).toBe(1);
    expect(plan.waves[0].nodeIds.length).toBe(5);

    const state = createExecutionState({ workflowId: 'test' });
    await execute(plan, state, { maxConcurrency: 2 });

    expect(state.status).toBe('completed');
    for (let i = 0; i < 5; i++) {
      expect(state.nodeResults.get(`node-${i}`)?.status).toBe('success');
    }
  });
});

// ============================================================================
// Map Transform Tests (verifying execution context)
// ============================================================================

describe('Map Transform Execution', () => {
  test('map transforms array', async () => {
    // First node provides array, second maps it
    const ast = createAST([
      {
        type: 'transform',
        id: 'data',
        transformType: 'template',
        config: { template: '{{JSON.stringify([1, 2, 3])}}' },
        loc: { start: { line: 1, column: 0, offset: 0 }, end: { line: 1, column: 10, offset: 10 } },
      },
    ]);

    const plan = buildExecutionPlan(ast);
    const state = createExecutionState({ workflowId: 'test' });
    await execute(plan, state);

    // This tests that template can output JSON-like strings
    // Full map tests are in transform.test.ts
    expect(state.status).toBe('completed');
  });
});

// ============================================================================
// State Tests
// ============================================================================

describe('Execution State', () => {
  test('records timing information', async () => {
    const ast = createAST([
      {
        type: 'transform',
        id: 'a',
        transformType: 'template',
        config: { template: 'Test' },
        loc: { start: { line: 1, column: 0, offset: 0 }, end: { line: 1, column: 10, offset: 10 } },
      },
    ]);

    const plan = buildExecutionPlan(ast);
    const state = createExecutionState({ workflowId: 'test' });

    const startTime = Date.now();
    await execute(plan, state);
    const endTime = Date.now();

    expect(state.startedAt).toBeLessThanOrEqual(startTime + 10);
    expect(state.completedAt).toBeDefined();
    expect(state.completedAt).toBeGreaterThanOrEqual(state.startedAt);
    expect(state.completedAt).toBeLessThanOrEqual(endTime + 10);

    const nodeResult = state.nodeResults.get('a')!;
    expect(nodeResult.duration).toBeGreaterThanOrEqual(0);
    expect(nodeResult.startedAt).toBeGreaterThanOrEqual(state.startedAt);
    expect(nodeResult.completedAt).toBeLessThanOrEqual(state.completedAt!);
  });

  test('tracks wave progress', async () => {
    const ast = createAST([
      {
        type: 'transform',
        id: 'a',
        transformType: 'template',
        config: { template: 'Wave 0' },
        loc: { start: { line: 1, column: 0, offset: 0 }, end: { line: 1, column: 10, offset: 10 } },
      },
      {
        type: 'transform',
        id: 'b',
        input: 'a',
        transformType: 'template',
        config: { template: 'Wave 1' },
        loc: { start: { line: 1, column: 0, offset: 0 }, end: { line: 1, column: 10, offset: 10 } },
      },
    ]);

    const plan = buildExecutionPlan(ast);
    const state = createExecutionState({ workflowId: 'test' });
    await execute(plan, state);

    // Final wave should be the last one processed
    expect(state.currentWave).toBe(1);
  });

  test('exposes node outputs in context', async () => {
    const ast = createAST([
      {
        type: 'transform',
        id: 'first',
        transformType: 'template',
        config: { template: 'Hello World' },
        loc: { start: { line: 1, column: 0, offset: 0 }, end: { line: 1, column: 10, offset: 10 } },
      },
      {
        type: 'transform',
        id: 'second',
        input: 'first',
        transformType: 'template',
        config: { template: 'Previous said: {{first.output}}' },
        loc: { start: { line: 1, column: 0, offset: 0 }, end: { line: 1, column: 10, offset: 10 } },
      },
    ]);

    const plan = buildExecutionPlan(ast);
    const state = createExecutionState({ workflowId: 'test' });
    await execute(plan, state);

    expect(state.nodeResults.get('second')?.output).toBe('Previous said: Hello World');
  });
});

// ============================================================================
// Error Handling Tests
// ============================================================================

describe('Error Handling', () => {
  test('marks state as failed on error', async () => {
    // Unknown runtime type will cause error
    const ast = createAST([
      {
        type: 'source',
        id: 'bad',
        sourceType: 'unknown-type',
        config: {},
        loc: { start: { line: 1, column: 0, offset: 0 }, end: { line: 1, column: 10, offset: 10 } },
      },
    ]);

    const plan = buildExecutionPlan(ast);
    const state = createExecutionState({ workflowId: 'test' });

    await expect(execute(plan, state)).rejects.toThrow();
    expect(state.status).toBe('failed');
    expect(state.completedAt).toBeDefined();
  });
});
```
  </action>
  <verify>bun test src/execution/executor.test.ts</verify>
  <done>Integration tests pass validating wave execution, concurrency, and state management</done>
</task>

</tasks>

<verification>
```bash
# Run executor integration tests
bun test src/execution/executor.test.ts

# Run all scheduler tests
bun test src/scheduler/scheduler.test.ts

# Run control flow tests (parallel should now be included)
bun test src/runtimes/control/control.test.ts

# Verify full test suite
bun test
```
</verification>

<success_criteria>
- [ ] Foreach with maxConcurrency > 1 runs iterations in parallel
- [ ] Results maintain index order in parallel foreach
- [ ] Break in parallel foreach only stops its iteration
- [ ] execute() exported from execution/index.ts
- [ ] Integration tests pass for wave execution
- [ ] Integration tests pass for concurrency limiting
- [ ] Integration tests pass for state management
- [ ] All existing tests still pass
</success_criteria>

<output>
After completion, create `.planning/phases/06-scheduling-parallelism/06-04-SUMMARY.md`
</output>
