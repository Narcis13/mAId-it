---
phase: 07-production-readiness
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/execution/retry.ts
  - src/execution/persistence.ts
  - src/execution/types.ts
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Retry wrapper executes node up to maxRetries times on retryable errors"
    - "Each retry waits with exponential backoff (uses existing calculateBackoffMs)"
    - "Node execution respects timeout configuration via AbortSignal"
    - "State can be serialized to JSON and restored with Map intact"
  artifacts:
    - src/execution/retry.ts
    - src/execution/persistence.ts
  key_links:
    - "retry.ts imports calculateBackoffMs from ../runtimes/ai/retry"
    - "persistence.ts exports saveState and loadState functions"
    - "types.ts extended with RetryConfig and PersistedState types"
---

<objective>
Create retry/timeout infrastructure and state persistence functions.

Purpose: Enable resilient node execution with configurable retries and timeouts, plus ability to save/restore workflow state for recovery.
Output: retry.ts with executeWithRetry wrapper, persistence.ts with save/load functions, extended types.ts
</objective>

<execution_context>
@/Users/narcisbrindusescu/.claude/looppool/workflows/execute-plan.md
@/Users/narcisbrindusescu/.claude/looppool/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/07-production-readiness/07-RESEARCH.md
@src/execution/types.ts
@src/execution/state.ts
@src/runtimes/ai/retry.ts
@src/runtimes/errors.ts
@src/runtimes/ai/errors.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add retry and persistence types to execution/types.ts</name>
  <files>src/execution/types.ts</files>
  <action>
Add the following types to execution/types.ts:

```typescript
/**
 * Retry configuration for node execution.
 */
export interface RetryConfig {
  /** Maximum retry attempts (default: 3) */
  maxRetries?: number;
  /** Base delay for exponential backoff in ms (default: 1000) */
  backoffBase?: number;
  /** Timeout in ms for each attempt (default: 30000) */
  timeout?: number;
  /** Node ID to execute if all retries fail */
  fallbackNodeId?: string;
}

/**
 * Persisted state format for JSON serialization.
 * Maps are converted to arrays for JSON compatibility.
 */
export interface PersistedState {
  workflowId: string;
  runId: string;
  status: ExecutionState['status'];
  currentWave: number;
  startedAt: number;
  completedAt?: number;
  /** nodeResults Map serialized as array of [nodeId, result] tuples */
  nodeResults: Array<[string, NodeResult]>;
  globalContext: Record<string, unknown>;
  phaseContext: Record<string, unknown>;
  nodeContext: Record<string, unknown>;
  config: Record<string, unknown>;
  secrets: Record<string, string>;
}
```
  </action>
  <verify>bun run tsc --noEmit src/execution/types.ts</verify>
  <done>RetryConfig and PersistedState types exist and compile without errors</done>
</task>

<task type="auto">
  <name>Task 2: Create retry wrapper in execution/retry.ts</name>
  <files>src/execution/retry.ts</files>
  <action>
Create src/execution/retry.ts with:

1. Import calculateBackoffMs and sleep from '../runtimes/ai/retry'
2. Import isRetryableError helper that checks:
   - HttpError.isRetryable
   - AIError.retryable
   - error.name === 'TimeoutError' (from AbortSignal.timeout)
   - NOT AbortError (user-initiated cancellation)

3. Create executeWithRetry function:
```typescript
/**
 * Execute a function with retry logic, timeout, and optional fallback.
 *
 * @param fn - Async function to execute
 * @param config - Retry configuration
 * @param onFallback - Optional fallback function if all retries fail
 * @returns Result of fn or fallback
 * @throws Last error if all retries exhausted and no fallback
 */
export async function executeWithRetry<T>(
  fn: (signal: AbortSignal) => Promise<T>,
  config: RetryConfig = {},
  onFallback?: () => Promise<T>
): Promise<T>
```

Implementation:
- Default maxRetries: 3, backoffBase: 1000, timeout: 30000
- Create AbortSignal.timeout(config.timeout) for each attempt
- Catch errors, check isRetryableError
- If retryable and attempts remaining: sleep(calculateBackoffMs(attempt, backoffBase))
- If all retries fail and onFallback provided, call it
- Otherwise throw last error

4. Export isRetryableError helper function:
```typescript
export function isRetryableError(error: unknown): boolean
```
  </action>
  <verify>bun test src/execution/retry.test.ts</verify>
  <done>
- executeWithRetry retries on HttpError.isRetryable and AIError.retryable
- executeWithRetry respects timeout via AbortSignal
- executeWithRetry calls fallback when all retries fail
- isRetryableError correctly classifies errors
  </done>
</task>

<task type="auto">
  <name>Task 3: Create persistence functions in execution/persistence.ts</name>
  <files>src/execution/persistence.ts</files>
  <action>
Create src/execution/persistence.ts with:

1. Import types: ExecutionState, ExecutionStateOptions, PersistedState, NodeResult

2. Create saveState function:
```typescript
/**
 * Save execution state to JSON file.
 * Converts Map to array for JSON serialization.
 *
 * @param state - Current execution state
 * @param filePath - Path to save state file
 */
export async function saveState(
  state: ExecutionState,
  filePath: string
): Promise<void>
```
- Convert nodeResults Map to Array.from(entries())
- Use Bun.write(filePath, JSON.stringify(persisted, null, 2))

3. Create loadState function:
```typescript
/**
 * Load execution state from JSON file.
 * Restores Map from array representation.
 *
 * @param filePath - Path to state file
 * @param overrides - Optional config/secrets overrides
 * @returns Restored execution state
 * @throws FileError if file not found
 */
export async function loadState(
  filePath: string,
  overrides?: { config?: Record<string, unknown>; secrets?: Record<string, string> }
): Promise<ExecutionState>
```
- Use Bun.file(filePath).json() to read
- Convert nodeResults array back to Map: new Map(persisted.nodeResults)
- Apply overrides if provided

4. Create getStatePath helper:
```typescript
/**
 * Generate state file path for a workflow run.
 * Uses pattern: .maidit-state/{workflowId}/{runId}.json
 */
export function getStatePath(workflowId: string, runId: string): string
```
  </action>
  <verify>bun test src/execution/persistence.test.ts</verify>
  <done>
- saveState writes JSON with nodeResults as array
- loadState restores state with nodeResults as Map
- Round-trip preserves all state fields including Map entries
- getStatePath returns correct pattern
  </done>
</task>

</tasks>

<verification>
Run all tests:
```bash
bun test src/execution/retry.test.ts src/execution/persistence.test.ts
```

Type check:
```bash
bun run tsc --noEmit src/execution/*.ts
```
</verification>

<success_criteria>
- [ ] RetryConfig and PersistedState types defined in types.ts
- [ ] executeWithRetry wrapper handles retries with backoff
- [ ] executeWithRetry respects timeout configuration
- [ ] isRetryableError classifies HttpError, AIError, TimeoutError
- [ ] saveState serializes Map to array
- [ ] loadState restores Map from array
- [ ] All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/07-production-readiness/07-01-SUMMARY.md`
</output>
