---
phase: 07-production-readiness
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/runtimes/checkpoint/types.ts
  - src/runtimes/checkpoint/runtime.ts
  - src/runtimes/checkpoint/index.ts
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Checkpoint runtime prompts user in terminal with message"
    - "User can respond with approve, reject, or provide text input"
    - "Checkpoint times out and uses default action when timeout expires"
    - "Non-TTY environments skip prompt and use default action immediately"
  artifacts:
    - src/runtimes/checkpoint/types.ts
    - src/runtimes/checkpoint/runtime.ts
    - src/runtimes/checkpoint/index.ts
  key_links:
    - "runtime.ts uses node:readline for terminal input"
    - "runtime.ts checks process.stdin.isTTY before prompting"
    - "index.ts registers checkpoint runtime with registry"
---

<objective>
Create checkpoint runtime for human-in-the-loop workflow pauses.

Purpose: Allow workflows to pause and prompt users for approval, rejection, or input before continuing.
Output: Checkpoint runtime implementation with terminal prompts, timeout support, and TTY detection.
</objective>

<execution_context>
@/Users/narcisbrindusescu/.claude/looppool/workflows/execute-plan.md
@/Users/narcisbrindusescu/.claude/looppool/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/07-production-readiness/07-RESEARCH.md
@src/runtimes/types.ts
@src/runtimes/registry.ts
@src/types/ast.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create checkpoint types in runtimes/checkpoint/types.ts</name>
  <files>src/runtimes/checkpoint/types.ts</files>
  <action>
Create src/runtimes/checkpoint/types.ts with:

```typescript
/**
 * Checkpoint Runtime Type Definitions
 *
 * Types for human-in-the-loop checkpoint nodes that pause
 * execution and prompt for user input.
 */

/**
 * User action at checkpoint.
 */
export type CheckpointAction = 'approve' | 'reject' | 'input';

/**
 * Configuration for checkpoint nodes.
 */
export interface CheckpointConfig {
  /** Message to display to user */
  message: string;
  /** Timeout in milliseconds before default action (optional) */
  timeout?: number;
  /** Action to take on timeout (default: 'reject') */
  defaultAction?: 'approve' | 'reject';
  /** Whether to allow text input (default: false) */
  allowInput?: boolean;
}

/**
 * Result from checkpoint execution.
 */
export interface CheckpointResult {
  /** User's action */
  action: CheckpointAction;
  /** User's text input (if allowInput was true and user chose input) */
  input?: string;
  /** Whether the checkpoint timed out */
  timedOut: boolean;
  /** Timestamp when user responded */
  respondedAt: number;
}
```
  </action>
  <verify>bun run tsc --noEmit src/runtimes/checkpoint/types.ts</verify>
  <done>CheckpointConfig and CheckpointResult types defined and compile</done>
</task>

<task type="auto">
  <name>Task 2: Create checkpoint runtime in runtimes/checkpoint/runtime.ts</name>
  <files>src/runtimes/checkpoint/runtime.ts</files>
  <action>
Create src/runtimes/checkpoint/runtime.ts with:

1. Import readline from 'node:readline'
2. Import NodeRuntime, ExecutionParams from '../types'
3. Import CheckpointConfig, CheckpointResult, CheckpointAction from './types'

4. Create CheckpointRuntime class:
```typescript
/**
 * Checkpoint Runtime - pauses execution for human interaction.
 *
 * Prompts user in terminal for approval, rejection, or text input.
 * Supports timeout with configurable default action.
 *
 * In non-TTY environments (CI, automated tests), uses default action
 * immediately without prompting.
 */
export class CheckpointRuntime implements NodeRuntime<CheckpointConfig, unknown, CheckpointResult> {
  readonly type = 'checkpoint';

  async execute(params: ExecutionParams<CheckpointConfig, unknown>): Promise<CheckpointResult>
}
```

Implementation details:
a) Check process.stdin.isTTY - if false, return default action immediately with timedOut: false
b) Create readline interface with input: process.stdin, output: process.stdout
c) Build prompt string:
   - Display config.message
   - Show options: "[A]pprove / [R]eject" (add "/ [I]nput" if allowInput)
d) If timeout configured:
   - Set setTimeout that closes readline and resolves with defaultAction
   - Clear timeout when user responds
e) Parse user input:
   - 'a' or 'approve' -> action: 'approve'
   - 'r' or 'reject' -> action: 'reject'
   - 'i' or 'input' (if allowInput) -> prompt for text, then action: 'input', input: text
   - Invalid input -> re-prompt (max 3 attempts, then use defaultAction or throw)
f) Close readline and return CheckpointResult

Handle edge cases:
- SIGINT during prompt -> action: 'reject', timedOut: false
- Empty input -> re-prompt
- Readline 'close' event without answer -> use defaultAction
  </action>
  <verify>bun test src/runtimes/checkpoint/runtime.test.ts</verify>
  <done>
- Checkpoint prompts for user input in TTY environment
- Checkpoint parses approve/reject/input responses
- Checkpoint times out and uses default action
- Checkpoint skips prompt in non-TTY environment
  </done>
</task>

<task type="auto">
  <name>Task 3: Create index and register checkpoint runtime</name>
  <files>src/runtimes/checkpoint/index.ts</files>
  <action>
Create src/runtimes/checkpoint/index.ts:

```typescript
/**
 * Checkpoint Runtime Exports
 *
 * Re-exports types and runtime, registers with global registry.
 */

export * from './types';
export { CheckpointRuntime } from './runtime';

// Auto-register with runtime registry
import { registerRuntime } from '../registry';
import { CheckpointRuntime } from './runtime';

const checkpointRuntime = new CheckpointRuntime();
registerRuntime('checkpoint', checkpointRuntime);
```

Then update src/runtimes/index.ts to import checkpoint:
- Add: import './checkpoint';
- Add to exports: export * from './checkpoint';
  </action>
  <verify>bun run -e "import { getRuntime, hasRuntime } from './src/runtimes'; console.log('checkpoint registered:', hasRuntime('checkpoint'))"</verify>
  <done>
- Checkpoint runtime registered as 'checkpoint' in registry
- Types and runtime exported from runtimes/index.ts
  </done>
</task>

</tasks>

<verification>
Run checkpoint tests:
```bash
bun test src/runtimes/checkpoint/runtime.test.ts
```

Verify registration:
```bash
bun run -e "import { hasRuntime } from './src/runtimes'; console.log('checkpoint:', hasRuntime('checkpoint'))"
```

Type check:
```bash
bun run tsc --noEmit src/runtimes/checkpoint/*.ts
```
</verification>

<success_criteria>
- [ ] CheckpointConfig and CheckpointResult types defined
- [ ] CheckpointRuntime implements NodeRuntime interface
- [ ] Terminal prompts work with approve/reject/input options
- [ ] Timeout triggers default action
- [ ] Non-TTY environments skip prompt
- [ ] Runtime registered as 'checkpoint' in registry
</success_criteria>

<output>
After completion, create `.planning/phases/07-production-readiness/07-02-SUMMARY.md`
</output>
