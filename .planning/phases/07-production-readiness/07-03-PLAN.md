---
phase: 07-production-readiness
plan: 03
type: execute
wave: 2
depends_on: ["07-01"]
files_modified:
  - src/execution/executor.ts
  - src/scheduler/types.ts
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Nodes with retry config are executed through executeWithRetry wrapper"
    - "Nodes respect per-node timeout configuration"
    - "Failed nodes with fallback config trigger fallback node execution"
    - "Workflow-level error handler receives error and state on unhandled failure"
    - "State persists to JSON file after each wave completes"
  artifacts:
    - src/execution/executor.ts (updated)
    - src/scheduler/types.ts (updated with ExecutionOptions)
  key_links:
    - "executor.ts imports executeWithRetry from ./retry"
    - "executor.ts imports saveState from ./persistence"
    - "ExecutionOptions extended with persistencePath and errorHandler"
---

<objective>
Integrate retry, timeout, fallback, error handling, and state persistence into the executor.

Purpose: Make the executor production-ready with resilient node execution and recovery capabilities.
Output: Updated executor with retry wrapper integration, fallback execution, error handlers, and state checkpointing.
</objective>

<execution_context>
@/Users/narcisbrindusescu/.claude/looppool/workflows/execute-plan.md
@/Users/narcisbrindusescu/.claude/looppool/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/07-production-readiness/07-RESEARCH.md
@.planning/phases/07-production-readiness/07-01-PLAN.md
@src/execution/executor.ts
@src/execution/types.ts
@src/scheduler/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend ExecutionOptions with production settings</name>
  <files>src/scheduler/types.ts</files>
  <action>
Update ExecutionOptions in src/scheduler/types.ts to add:

```typescript
/**
 * Options for workflow execution.
 */
export interface ExecutionOptions {
  /** Maximum concurrent nodes per wave (default: 10) */
  maxConcurrency?: number;
  /** Workflow execution timeout in ms */
  timeout?: number;

  // Production readiness additions:

  /** Path to persist state after each wave (enables checkpointing) */
  persistencePath?: string;
  /** Workflow-level error handler for unhandled failures */
  errorHandler?: (error: Error, state: ExecutionState) => void | Promise<void>;
  /** Default retry config applied to all nodes (can be overridden per-node) */
  defaultRetryConfig?: RetryConfig;
}
```

Import RetryConfig and ExecutionState from execution/types.ts.
  </action>
  <verify>bun run tsc --noEmit src/scheduler/types.ts</verify>
  <done>ExecutionOptions includes persistencePath, errorHandler, and defaultRetryConfig</done>
</task>

<task type="auto">
  <name>Task 2: Integrate retry wrapper into executor</name>
  <files>src/execution/executor.ts</files>
  <action>
Update src/execution/executor.ts:

1. Import new dependencies:
```typescript
import { executeWithRetry, isRetryableError } from './retry';
import { saveState } from './persistence';
import type { RetryConfig } from './types';
```

2. Add helper to extract retry config from node:
```typescript
/**
 * Get retry configuration for a node.
 * Looks for retry config in node.config, falls back to execution options default.
 */
function getNodeRetryConfig(
  node: NodeAST,
  defaultConfig?: RetryConfig
): RetryConfig | undefined {
  const nodeConfig = node.config as Record<string, unknown> | undefined;
  if (nodeConfig?.retry) {
    return nodeConfig.retry as RetryConfig;
  }
  return defaultConfig;
}
```

3. Update executeNode to use retry wrapper when config present:
- Extract retry config using helper
- If retry config exists:
  - Wrap runtime.execute call in executeWithRetry
  - Pass AbortSignal from retry wrapper to runtime (if runtime supports it)
  - If fallbackNodeId specified and all retries fail, call executeFallbackNode

4. Add executeFallbackNode function:
```typescript
/**
 * Execute a fallback node when primary fails.
 * Passes original input and primary error to fallback context.
 */
async function executeFallbackNode(
  fallbackNodeId: string,
  nodes: Map<string, NodeAST>,
  state: ExecutionState,
  originalInput: unknown,
  primaryError: Error,
  maxConcurrency: number
): Promise<unknown>
```
- Look up fallback node from nodes map
- Add to state.nodeContext: { $primaryError: primaryError.message, $primaryInput: originalInput }
- Call executeNode on fallback
- Return fallback result output
  </action>
  <verify>bun test src/execution/executor.test.ts --grep "retry"</verify>
  <done>
- executeNode uses retry wrapper when retry config present
- Fallback node executes when primary fails after retries
- Fallback receives primary error in context
  </done>
</task>

<task type="auto">
  <name>Task 3: Add error handler and state persistence to execute()</name>
  <files>src/execution/executor.ts</files>
  <action>
Update the main execute() function:

1. Extract options:
```typescript
const { persistencePath, errorHandler, defaultRetryConfig } = options;
```

2. After each wave completes successfully, persist state:
```typescript
// Inside the for loop, after executeWave:
if (persistencePath) {
  await saveState(state, persistencePath);
}
```

3. In the catch block, invoke workflow-level error handler:
```typescript
catch (error) {
  state.status = 'failed';
  state.completedAt = Date.now();

  // Persist final failed state
  if (persistencePath) {
    await saveState(state, persistencePath);
  }

  // Invoke workflow-level error handler
  if (errorHandler) {
    try {
      await errorHandler(error as Error, state);
    } catch (handlerError) {
      // Log but don't mask original error
      console.error('Error handler failed:', handlerError);
    }
  }

  throw error;
}
```

4. Pass defaultRetryConfig through to executeWave and executeNode:
- Update executeWave signature to accept defaultRetryConfig
- Pass it through to executeNode calls
  </action>
  <verify>bun test src/execution/executor.test.ts --grep "persistence\|error handler"</verify>
  <done>
- State persists after each wave when persistencePath provided
- Error handler invoked on workflow failure
- Error handler errors are caught and logged
- Original error still thrown after error handler
  </done>
</task>

</tasks>

<verification>
Run executor tests:
```bash
bun test src/execution/executor.test.ts
```

Run all execution tests:
```bash
bun test src/execution/
```

Type check:
```bash
bun run tsc --noEmit src/execution/*.ts src/scheduler/types.ts
```
</verification>

<success_criteria>
- [ ] ExecutionOptions extended with persistencePath, errorHandler, defaultRetryConfig
- [ ] Nodes with retry config use executeWithRetry wrapper
- [ ] Fallback nodes execute when primary fails after retries
- [ ] State persists to file after each wave
- [ ] Workflow-level error handler invoked on failure
- [ ] All existing executor tests still pass
</success_criteria>

<output>
After completion, create `.planning/phases/07-production-readiness/07-03-SUMMARY.md`
</output>
