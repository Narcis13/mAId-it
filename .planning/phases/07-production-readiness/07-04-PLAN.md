---
phase: 07-production-readiness
plan: 04
type: execute
wave: 2
depends_on: ["07-01"]
files_modified:
  - src/execution/resume.ts
  - src/execution/logging.ts
  - src/execution/index.ts
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Workflow can resume from persisted state file starting at next wave"
    - "Execution log formats as human-readable markdown with run metadata"
    - "Log includes per-node timing and status in table format"
    - "Log appends to workflow markdown file (or replaces existing log section)"
  artifacts:
    - src/execution/resume.ts
    - src/execution/logging.ts
  key_links:
    - "resume.ts imports loadState from ./persistence"
    - "resume.ts imports buildExecutionPlan from ../scheduler"
    - "logging.ts exports formatExecutionLog and appendExecutionLog"
    - "index.ts exports resume and logging functions"
---

<objective>
Create workflow resume capability and execution logging.

Purpose: Enable failed workflows to resume from checkpoint, and provide audit trail via markdown logs.
Output: resume.ts for checkpoint recovery, logging.ts for formatted execution logs.
</objective>

<execution_context>
@/Users/narcisbrindusescu/.claude/looppool/workflows/execute-plan.md
@/Users/narcisbrindusescu/.claude/looppool/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/07-production-readiness/07-RESEARCH.md
@.planning/phases/07-production-readiness/07-01-PLAN.md
@src/execution/types.ts
@src/execution/executor.ts
@src/scheduler/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create resume functionality in execution/resume.ts</name>
  <files>src/execution/resume.ts</files>
  <action>
Create src/execution/resume.ts with:

1. Imports:
```typescript
import type { WorkflowAST } from '../types/ast';
import type { ExecutionState } from './types';
import type { ExecutionOptions, ExecutionPlan } from '../scheduler/types';
import { loadState } from './persistence';
import { buildExecutionPlan } from '../scheduler';
import { execute } from './executor';
```

2. Create resumeWorkflow function:
```typescript
/**
 * Resume a workflow from a persisted checkpoint.
 *
 * Loads the saved state, rebuilds the execution plan, and continues
 * from the wave after the last completed wave.
 *
 * @param ast - Original workflow AST
 * @param checkpointPath - Path to persisted state file
 * @param options - Execution options (can override config/secrets)
 * @returns Promise that resolves when workflow completes
 *
 * @example
 * ```typescript
 * // Resume from checkpoint
 * await resumeWorkflow(ast, '.maidit-state/workflow/run123.json', {
 *   secrets: { API_KEY: 'new-key' }  // Override with fresh secrets
 * });
 * ```
 */
export async function resumeWorkflow(
  ast: WorkflowAST,
  checkpointPath: string,
  options: ExecutionOptions & {
    config?: Record<string, unknown>;
    secrets?: Record<string, string>;
  } = {}
): Promise<ExecutionState>
```

Implementation:
a) Load state: `const state = await loadState(checkpointPath, { config, secrets })`
b) Reset status to 'running'
c) Build full plan: `const fullPlan = buildExecutionPlan(ast)`
d) Filter waves to only those after state.currentWave:
```typescript
const remainingWaves = fullPlan.waves.filter(
  wave => wave.waveNumber > state.currentWave
);
```
e) Create resume plan:
```typescript
const resumePlan: ExecutionPlan = {
  waves: remainingWaves,
  nodes: fullPlan.nodes,
};
```
f) Call execute with resume plan and loaded state
g) Return final state

3. Add helper to check if workflow can be resumed:
```typescript
/**
 * Check if a workflow run can be resumed.
 * Returns true if state file exists and status is 'failed' or 'cancelled'.
 */
export async function canResume(checkpointPath: string): Promise<boolean>
```
  </action>
  <verify>bun test src/execution/resume.test.ts</verify>
  <done>
- resumeWorkflow loads state and continues from next wave
- resumeWorkflow applies config/secrets overrides
- canResume returns true for failed/cancelled, false for completed
  </done>
</task>

<task type="auto">
  <name>Task 2: Create execution logging in execution/logging.ts</name>
  <files>src/execution/logging.ts</files>
  <action>
Create src/execution/logging.ts with:

1. Types:
```typescript
/**
 * Entry for execution log.
 */
export interface ExecutionLogEntry {
  runId: string;
  workflowId: string;
  timestamp: number;  // startedAt
  duration: number;   // ms
  status: 'completed' | 'failed';
  waveCount: number;
  nodeResults: Map<string, NodeResult>;
}
```

2. Create formatExecutionLog function:
```typescript
/**
 * Format execution state as markdown log entry.
 *
 * @param state - Final execution state
 * @returns Markdown-formatted log string
 */
export function formatExecutionLog(state: ExecutionState): string
```

Output format:
```markdown
---

## Execution Log

**Run ID:** `{runId}`
**Workflow:** {workflowId}
**Timestamp:** {ISO date}
**Duration:** {seconds}s
**Status:** {completed|failed}
**Waves:** {waveCount}

### Node Results

| Node | Status | Duration | Output |
|------|--------|----------|--------|
| nodeId1 | success | 0.12s | {"key": "va...} |
| nodeId2 | failed | 0.05s | Error: ... |
```

Implementation notes:
- Use toISOString() for timestamp
- Truncate output to 50 chars max with '...'
- Escape pipe characters in output
- Sort nodes by execution order (startedAt)

3. Create appendExecutionLog function:
```typescript
/**
 * Append execution log to workflow markdown file.
 *
 * If a log section exists (starts with "## Execution Log"), replaces it.
 * Otherwise appends new log section.
 *
 * @param workflowPath - Path to workflow .flow.md file
 * @param state - Final execution state
 */
export async function appendExecutionLog(
  workflowPath: string,
  state: ExecutionState
): Promise<void>
```

Implementation:
a) Read existing file content with Bun.file(workflowPath).text()
b) Format log entry
c) Check if file contains "## Execution Log" marker
d) If exists: replace from marker to end of file
e) If not: append log entry
f) Write with Bun.write(workflowPath, updated)
  </action>
  <verify>bun test src/execution/logging.test.ts</verify>
  <done>
- formatExecutionLog produces valid markdown
- Log includes run ID, timestamp, duration, status
- Log includes per-node table with timing
- appendExecutionLog adds to file
- appendExecutionLog replaces existing log section
  </done>
</task>

<task type="auto">
  <name>Task 3: Update execution index exports</name>
  <files>src/execution/index.ts</files>
  <action>
Update src/execution/index.ts to export new modules:

Add exports:
```typescript
// Retry utilities
export { executeWithRetry, isRetryableError } from './retry';

// State persistence
export { saveState, loadState, getStatePath } from './persistence';

// Workflow resume
export { resumeWorkflow, canResume } from './resume';

// Execution logging
export { formatExecutionLog, appendExecutionLog } from './logging';
export type { ExecutionLogEntry } from './logging';
```

Verify existing exports are preserved:
- execute
- createExecutionState
- evaluateTemplateInContext (if exists)
- All type exports
  </action>
  <verify>bun run -e "import * as exec from './src/execution'; console.log(Object.keys(exec).sort().join(', '))"</verify>
  <done>
- All new functions exported from execution/index.ts
- All existing exports preserved
- Types exported for consumers
  </done>
</task>

</tasks>

<verification>
Run all execution tests:
```bash
bun test src/execution/
```

Check exports:
```bash
bun run -e "import { resumeWorkflow, appendExecutionLog, executeWithRetry, saveState } from './src/execution'; console.log('All imports work')"
```

Type check:
```bash
bun run tsc --noEmit src/execution/*.ts
```
</verification>

<success_criteria>
- [ ] resumeWorkflow loads state and continues from next wave
- [ ] resumeWorkflow applies config/secrets overrides
- [ ] formatExecutionLog produces markdown with run metadata
- [ ] formatExecutionLog includes per-node timing table
- [ ] appendExecutionLog adds/replaces log section in workflow file
- [ ] All new functions exported from execution/index.ts
- [ ] All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/07-production-readiness/07-04-SUMMARY.md`
</output>
